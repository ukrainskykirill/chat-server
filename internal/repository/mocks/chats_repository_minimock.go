// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ukrainskykirill/chat-server/internal/repository.ChatsRepository -o chats_repository_minimock.go -n ChatsRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ChatsRepositoryMock implements repository.ChatsRepository
type ChatsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, isRegular bool) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, isRegular bool)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatsRepositoryMockCreate

	funcCreateChatUsers          func(ctx context.Context, chatID int64, userIDs []int64) (err error)
	inspectFuncCreateChatUsers   func(ctx context.Context, chatID int64, userIDs []int64)
	afterCreateChatUsersCounter  uint64
	beforeCreateChatUsersCounter uint64
	CreateChatUsersMock          mChatsRepositoryMockCreateChatUsers

	funcDeleteChat          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatsRepositoryMockDeleteChat

	funcDeleteChatUsers          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDeleteChatUsers   func(ctx context.Context, chatID int64)
	afterDeleteChatUsersCounter  uint64
	beforeDeleteChatUsersCounter uint64
	DeleteChatUsersMock          mChatsRepositoryMockDeleteChatUsers

	funcGetChatUserID          func(ctx context.Context, chatID int64, userID int64) (i1 int64, err error)
	inspectFuncGetChatUserID   func(ctx context.Context, chatID int64, userID int64)
	afterGetChatUserIDCounter  uint64
	beforeGetChatUserIDCounter uint64
	GetChatUserIDMock          mChatsRepositoryMockGetChatUserID
}

// NewChatsRepositoryMock returns a mock for repository.ChatsRepository
func NewChatsRepositoryMock(t minimock.Tester) *ChatsRepositoryMock {
	m := &ChatsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mChatsRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatsRepositoryMockCreateParams{}

	m.CreateChatUsersMock = mChatsRepositoryMockCreateChatUsers{mock: m}
	m.CreateChatUsersMock.callArgs = []*ChatsRepositoryMockCreateChatUsersParams{}

	m.DeleteChatMock = mChatsRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatsRepositoryMockDeleteChatParams{}

	m.DeleteChatUsersMock = mChatsRepositoryMockDeleteChatUsers{mock: m}
	m.DeleteChatUsersMock.callArgs = []*ChatsRepositoryMockDeleteChatUsersParams{}

	m.GetChatUserIDMock = mChatsRepositoryMockGetChatUserID{mock: m}
	m.GetChatUserIDMock.callArgs = []*ChatsRepositoryMockGetChatUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatsRepositoryMockCreate struct {
	optional           bool
	mock               *ChatsRepositoryMock
	defaultExpectation *ChatsRepositoryMockCreateExpectation
	expectations       []*ChatsRepositoryMockCreateExpectation

	callArgs []*ChatsRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsRepositoryMockCreateExpectation specifies expectation struct of the ChatsRepository.Create
type ChatsRepositoryMockCreateExpectation struct {
	mock      *ChatsRepositoryMock
	params    *ChatsRepositoryMockCreateParams
	paramPtrs *ChatsRepositoryMockCreateParamPtrs
	results   *ChatsRepositoryMockCreateResults
	Counter   uint64
}

// ChatsRepositoryMockCreateParams contains parameters of the ChatsRepository.Create
type ChatsRepositoryMockCreateParams struct {
	ctx       context.Context
	isRegular bool
}

// ChatsRepositoryMockCreateParamPtrs contains pointers to parameters of the ChatsRepository.Create
type ChatsRepositoryMockCreateParamPtrs struct {
	ctx       *context.Context
	isRegular *bool
}

// ChatsRepositoryMockCreateResults contains results of the ChatsRepository.Create
type ChatsRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mChatsRepositoryMockCreate) Optional() *mChatsRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ChatsRepository.Create
func (mmCreate *mChatsRepositoryMockCreate) Expect(ctx context.Context, isRegular bool) *mChatsRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ChatsRepositoryMockCreateParams{ctx, isRegular}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ChatsRepository.Create
func (mmCreate *mChatsRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mChatsRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatsRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectIsRegularParam2 sets up expected param isRegular for ChatsRepository.Create
func (mmCreate *mChatsRepositoryMockCreate) ExpectIsRegularParam2(isRegular bool) *mChatsRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatsRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.isRegular = &isRegular

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatsRepository.Create
func (mmCreate *mChatsRepositoryMockCreate) Inspect(f func(ctx context.Context, isRegular bool)) *mChatsRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatsRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatsRepository.Create
func (mmCreate *mChatsRepositoryMockCreate) Return(i1 int64, err error) *ChatsRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatsRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ChatsRepository.Create method
func (mmCreate *mChatsRepositoryMockCreate) Set(f func(ctx context.Context, isRegular bool) (i1 int64, err error)) *ChatsRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatsRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatsRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ChatsRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatsRepositoryMockCreate) When(ctx context.Context, isRegular bool) *ChatsRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsRepositoryMock.Create mock is already set by Set")
	}

	expectation := &ChatsRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatsRepositoryMockCreateParams{ctx, isRegular},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatsRepository.Create return parameters for the expectation previously defined by the When method
func (e *ChatsRepositoryMockCreateExpectation) Then(i1 int64, err error) *ChatsRepositoryMock {
	e.results = &ChatsRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times ChatsRepository.Create should be invoked
func (mmCreate *mChatsRepositoryMockCreate) Times(n uint64) *mChatsRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ChatsRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mChatsRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.ChatsRepository
func (mmCreate *ChatsRepositoryMock) Create(ctx context.Context, isRegular bool) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, isRegular)
	}

	mm_params := ChatsRepositoryMockCreateParams{ctx, isRegular}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ChatsRepositoryMockCreateParams{ctx, isRegular}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ChatsRepositoryMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.isRegular != nil && !minimock.Equal(*mm_want_ptrs.isRegular, mm_got.isRegular) {
				mmCreate.t.Errorf("ChatsRepositoryMock.Create got unexpected parameter isRegular, want: %#v, got: %#v%s\n", *mm_want_ptrs.isRegular, mm_got.isRegular, minimock.Diff(*mm_want_ptrs.isRegular, mm_got.isRegular))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatsRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatsRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, isRegular)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatsRepositoryMock.Create. %v %v", ctx, isRegular)
	return
}

// CreateAfterCounter returns a count of finished ChatsRepositoryMock.Create invocations
func (mmCreate *ChatsRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatsRepositoryMock.Create invocations
func (mmCreate *ChatsRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatsRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatsRepositoryMockCreate) Calls() []*ChatsRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatsRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatsRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatsRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatsRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to ChatsRepositoryMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsRepositoryMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mChatsRepositoryMockCreateChatUsers struct {
	optional           bool
	mock               *ChatsRepositoryMock
	defaultExpectation *ChatsRepositoryMockCreateChatUsersExpectation
	expectations       []*ChatsRepositoryMockCreateChatUsersExpectation

	callArgs []*ChatsRepositoryMockCreateChatUsersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsRepositoryMockCreateChatUsersExpectation specifies expectation struct of the ChatsRepository.CreateChatUsers
type ChatsRepositoryMockCreateChatUsersExpectation struct {
	mock      *ChatsRepositoryMock
	params    *ChatsRepositoryMockCreateChatUsersParams
	paramPtrs *ChatsRepositoryMockCreateChatUsersParamPtrs
	results   *ChatsRepositoryMockCreateChatUsersResults
	Counter   uint64
}

// ChatsRepositoryMockCreateChatUsersParams contains parameters of the ChatsRepository.CreateChatUsers
type ChatsRepositoryMockCreateChatUsersParams struct {
	ctx     context.Context
	chatID  int64
	userIDs []int64
}

// ChatsRepositoryMockCreateChatUsersParamPtrs contains pointers to parameters of the ChatsRepository.CreateChatUsers
type ChatsRepositoryMockCreateChatUsersParamPtrs struct {
	ctx     *context.Context
	chatID  *int64
	userIDs *[]int64
}

// ChatsRepositoryMockCreateChatUsersResults contains results of the ChatsRepository.CreateChatUsers
type ChatsRepositoryMockCreateChatUsersResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Optional() *mChatsRepositoryMockCreateChatUsers {
	mmCreateChatUsers.optional = true
	return mmCreateChatUsers
}

// Expect sets up expected params for ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Expect(ctx context.Context, chatID int64, userIDs []int64) *mChatsRepositoryMockCreateChatUsers {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	if mmCreateChatUsers.defaultExpectation == nil {
		mmCreateChatUsers.defaultExpectation = &ChatsRepositoryMockCreateChatUsersExpectation{}
	}

	if mmCreateChatUsers.defaultExpectation.paramPtrs != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by ExpectParams functions")
	}

	mmCreateChatUsers.defaultExpectation.params = &ChatsRepositoryMockCreateChatUsersParams{ctx, chatID, userIDs}
	for _, e := range mmCreateChatUsers.expectations {
		if minimock.Equal(e.params, mmCreateChatUsers.defaultExpectation.params) {
			mmCreateChatUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChatUsers.defaultExpectation.params)
		}
	}

	return mmCreateChatUsers
}

// ExpectCtxParam1 sets up expected param ctx for ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) ExpectCtxParam1(ctx context.Context) *mChatsRepositoryMockCreateChatUsers {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	if mmCreateChatUsers.defaultExpectation == nil {
		mmCreateChatUsers.defaultExpectation = &ChatsRepositoryMockCreateChatUsersExpectation{}
	}

	if mmCreateChatUsers.defaultExpectation.params != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Expect")
	}

	if mmCreateChatUsers.defaultExpectation.paramPtrs == nil {
		mmCreateChatUsers.defaultExpectation.paramPtrs = &ChatsRepositoryMockCreateChatUsersParamPtrs{}
	}
	mmCreateChatUsers.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChatUsers
}

// ExpectChatIDParam2 sets up expected param chatID for ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) ExpectChatIDParam2(chatID int64) *mChatsRepositoryMockCreateChatUsers {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	if mmCreateChatUsers.defaultExpectation == nil {
		mmCreateChatUsers.defaultExpectation = &ChatsRepositoryMockCreateChatUsersExpectation{}
	}

	if mmCreateChatUsers.defaultExpectation.params != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Expect")
	}

	if mmCreateChatUsers.defaultExpectation.paramPtrs == nil {
		mmCreateChatUsers.defaultExpectation.paramPtrs = &ChatsRepositoryMockCreateChatUsersParamPtrs{}
	}
	mmCreateChatUsers.defaultExpectation.paramPtrs.chatID = &chatID

	return mmCreateChatUsers
}

// ExpectUserIDsParam3 sets up expected param userIDs for ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) ExpectUserIDsParam3(userIDs []int64) *mChatsRepositoryMockCreateChatUsers {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	if mmCreateChatUsers.defaultExpectation == nil {
		mmCreateChatUsers.defaultExpectation = &ChatsRepositoryMockCreateChatUsersExpectation{}
	}

	if mmCreateChatUsers.defaultExpectation.params != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Expect")
	}

	if mmCreateChatUsers.defaultExpectation.paramPtrs == nil {
		mmCreateChatUsers.defaultExpectation.paramPtrs = &ChatsRepositoryMockCreateChatUsersParamPtrs{}
	}
	mmCreateChatUsers.defaultExpectation.paramPtrs.userIDs = &userIDs

	return mmCreateChatUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Inspect(f func(ctx context.Context, chatID int64, userIDs []int64)) *mChatsRepositoryMockCreateChatUsers {
	if mmCreateChatUsers.mock.inspectFuncCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("Inspect function is already set for ChatsRepositoryMock.CreateChatUsers")
	}

	mmCreateChatUsers.mock.inspectFuncCreateChatUsers = f

	return mmCreateChatUsers
}

// Return sets up results that will be returned by ChatsRepository.CreateChatUsers
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Return(err error) *ChatsRepositoryMock {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	if mmCreateChatUsers.defaultExpectation == nil {
		mmCreateChatUsers.defaultExpectation = &ChatsRepositoryMockCreateChatUsersExpectation{mock: mmCreateChatUsers.mock}
	}
	mmCreateChatUsers.defaultExpectation.results = &ChatsRepositoryMockCreateChatUsersResults{err}
	return mmCreateChatUsers.mock
}

// Set uses given function f to mock the ChatsRepository.CreateChatUsers method
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Set(f func(ctx context.Context, chatID int64, userIDs []int64) (err error)) *ChatsRepositoryMock {
	if mmCreateChatUsers.defaultExpectation != nil {
		mmCreateChatUsers.mock.t.Fatalf("Default expectation is already set for the ChatsRepository.CreateChatUsers method")
	}

	if len(mmCreateChatUsers.expectations) > 0 {
		mmCreateChatUsers.mock.t.Fatalf("Some expectations are already set for the ChatsRepository.CreateChatUsers method")
	}

	mmCreateChatUsers.mock.funcCreateChatUsers = f
	return mmCreateChatUsers.mock
}

// When sets expectation for the ChatsRepository.CreateChatUsers which will trigger the result defined by the following
// Then helper
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) When(ctx context.Context, chatID int64, userIDs []int64) *ChatsRepositoryMockCreateChatUsersExpectation {
	if mmCreateChatUsers.mock.funcCreateChatUsers != nil {
		mmCreateChatUsers.mock.t.Fatalf("ChatsRepositoryMock.CreateChatUsers mock is already set by Set")
	}

	expectation := &ChatsRepositoryMockCreateChatUsersExpectation{
		mock:   mmCreateChatUsers.mock,
		params: &ChatsRepositoryMockCreateChatUsersParams{ctx, chatID, userIDs},
	}
	mmCreateChatUsers.expectations = append(mmCreateChatUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatsRepository.CreateChatUsers return parameters for the expectation previously defined by the When method
func (e *ChatsRepositoryMockCreateChatUsersExpectation) Then(err error) *ChatsRepositoryMock {
	e.results = &ChatsRepositoryMockCreateChatUsersResults{err}
	return e.mock
}

// Times sets number of times ChatsRepository.CreateChatUsers should be invoked
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Times(n uint64) *mChatsRepositoryMockCreateChatUsers {
	if n == 0 {
		mmCreateChatUsers.mock.t.Fatalf("Times of ChatsRepositoryMock.CreateChatUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChatUsers.expectedInvocations, n)
	return mmCreateChatUsers
}

func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) invocationsDone() bool {
	if len(mmCreateChatUsers.expectations) == 0 && mmCreateChatUsers.defaultExpectation == nil && mmCreateChatUsers.mock.funcCreateChatUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChatUsers.mock.afterCreateChatUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChatUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChatUsers implements repository.ChatsRepository
func (mmCreateChatUsers *ChatsRepositoryMock) CreateChatUsers(ctx context.Context, chatID int64, userIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmCreateChatUsers.beforeCreateChatUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChatUsers.afterCreateChatUsersCounter, 1)

	if mmCreateChatUsers.inspectFuncCreateChatUsers != nil {
		mmCreateChatUsers.inspectFuncCreateChatUsers(ctx, chatID, userIDs)
	}

	mm_params := ChatsRepositoryMockCreateChatUsersParams{ctx, chatID, userIDs}

	// Record call args
	mmCreateChatUsers.CreateChatUsersMock.mutex.Lock()
	mmCreateChatUsers.CreateChatUsersMock.callArgs = append(mmCreateChatUsers.CreateChatUsersMock.callArgs, &mm_params)
	mmCreateChatUsers.CreateChatUsersMock.mutex.Unlock()

	for _, e := range mmCreateChatUsers.CreateChatUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateChatUsers.CreateChatUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChatUsers.CreateChatUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChatUsers.CreateChatUsersMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChatUsers.CreateChatUsersMock.defaultExpectation.paramPtrs

		mm_got := ChatsRepositoryMockCreateChatUsersParams{ctx, chatID, userIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChatUsers.t.Errorf("ChatsRepositoryMock.CreateChatUsers got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmCreateChatUsers.t.Errorf("ChatsRepositoryMock.CreateChatUsers got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.userIDs != nil && !minimock.Equal(*mm_want_ptrs.userIDs, mm_got.userIDs) {
				mmCreateChatUsers.t.Errorf("ChatsRepositoryMock.CreateChatUsers got unexpected parameter userIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.userIDs, mm_got.userIDs, minimock.Diff(*mm_want_ptrs.userIDs, mm_got.userIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChatUsers.t.Errorf("ChatsRepositoryMock.CreateChatUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChatUsers.CreateChatUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChatUsers.t.Fatal("No results are set for the ChatsRepositoryMock.CreateChatUsers")
		}
		return (*mm_results).err
	}
	if mmCreateChatUsers.funcCreateChatUsers != nil {
		return mmCreateChatUsers.funcCreateChatUsers(ctx, chatID, userIDs)
	}
	mmCreateChatUsers.t.Fatalf("Unexpected call to ChatsRepositoryMock.CreateChatUsers. %v %v %v", ctx, chatID, userIDs)
	return
}

// CreateChatUsersAfterCounter returns a count of finished ChatsRepositoryMock.CreateChatUsers invocations
func (mmCreateChatUsers *ChatsRepositoryMock) CreateChatUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUsers.afterCreateChatUsersCounter)
}

// CreateChatUsersBeforeCounter returns a count of ChatsRepositoryMock.CreateChatUsers invocations
func (mmCreateChatUsers *ChatsRepositoryMock) CreateChatUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUsers.beforeCreateChatUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatsRepositoryMock.CreateChatUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChatUsers *mChatsRepositoryMockCreateChatUsers) Calls() []*ChatsRepositoryMockCreateChatUsersParams {
	mmCreateChatUsers.mutex.RLock()

	argCopy := make([]*ChatsRepositoryMockCreateChatUsersParams, len(mmCreateChatUsers.callArgs))
	copy(argCopy, mmCreateChatUsers.callArgs)

	mmCreateChatUsers.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatUsersDone returns true if the count of the CreateChatUsers invocations corresponds
// the number of defined expectations
func (m *ChatsRepositoryMock) MinimockCreateChatUsersDone() bool {
	if m.CreateChatUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatUsersMock.invocationsDone()
}

// MinimockCreateChatUsersInspect logs each unmet expectation
func (m *ChatsRepositoryMock) MinimockCreateChatUsersInspect() {
	for _, e := range m.CreateChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsRepositoryMock.CreateChatUsers with params: %#v", *e.params)
		}
	}

	afterCreateChatUsersCounter := mm_atomic.LoadUint64(&m.afterCreateChatUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatUsersMock.defaultExpectation != nil && afterCreateChatUsersCounter < 1 {
		if m.CreateChatUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsRepositoryMock.CreateChatUsers")
		} else {
			m.t.Errorf("Expected call to ChatsRepositoryMock.CreateChatUsers with params: %#v", *m.CreateChatUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChatUsers != nil && afterCreateChatUsersCounter < 1 {
		m.t.Error("Expected call to ChatsRepositoryMock.CreateChatUsers")
	}

	if !m.CreateChatUsersMock.invocationsDone() && afterCreateChatUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsRepositoryMock.CreateChatUsers but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatUsersMock.expectedInvocations), afterCreateChatUsersCounter)
	}
}

type mChatsRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatsRepositoryMock
	defaultExpectation *ChatsRepositoryMockDeleteChatExpectation
	expectations       []*ChatsRepositoryMockDeleteChatExpectation

	callArgs []*ChatsRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatsRepository.DeleteChat
type ChatsRepositoryMockDeleteChatExpectation struct {
	mock      *ChatsRepositoryMock
	params    *ChatsRepositoryMockDeleteChatParams
	paramPtrs *ChatsRepositoryMockDeleteChatParamPtrs
	results   *ChatsRepositoryMockDeleteChatResults
	Counter   uint64
}

// ChatsRepositoryMockDeleteChatParams contains parameters of the ChatsRepository.DeleteChat
type ChatsRepositoryMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatsRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatsRepository.DeleteChat
type ChatsRepositoryMockDeleteChatParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatsRepositoryMockDeleteChatResults contains results of the ChatsRepository.DeleteChat
type ChatsRepositoryMockDeleteChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Optional() *mChatsRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatsRepository.DeleteChat
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatsRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatsRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatsRepositoryMockDeleteChatParams{ctx, chatID}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatsRepository.DeleteChat
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatsRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatsRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatsRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatsRepository.DeleteChat
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) ExpectChatIDParam2(chatID int64) *mChatsRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatsRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatsRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.chatID = &chatID

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatsRepository.DeleteChat
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatsRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatsRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatsRepository.DeleteChat
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Return(err error) *ChatsRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatsRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatsRepositoryMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatsRepository.DeleteChat method
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatsRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatsRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatsRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatsRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) When(ctx context.Context, chatID int64) *ChatsRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatsRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatsRepositoryMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatsRepositoryMockDeleteChatParams{ctx, chatID},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatsRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatsRepositoryMockDeleteChatExpectation) Then(err error) *ChatsRepositoryMock {
	e.results = &ChatsRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatsRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Times(n uint64) *mChatsRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatsRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	return mmDeleteChat
}

func (mmDeleteChat *mChatsRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements repository.ChatsRepository
func (mmDeleteChat *ChatsRepositoryMock) DeleteChat(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatsRepositoryMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatsRepositoryMockDeleteChatParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatsRepositoryMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteChat.t.Errorf("ChatsRepositoryMock.DeleteChat got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatsRepositoryMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatsRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatsRepositoryMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatsRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatsRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatsRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatsRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatsRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatsRepositoryMockDeleteChat) Calls() []*ChatsRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatsRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatsRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatsRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsRepositoryMock.DeleteChat with params: %#v", *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsRepositoryMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatsRepositoryMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Error("Expected call to ChatsRepositoryMock.DeleteChat")
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsRepositoryMock.DeleteChat but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
	}
}

type mChatsRepositoryMockDeleteChatUsers struct {
	optional           bool
	mock               *ChatsRepositoryMock
	defaultExpectation *ChatsRepositoryMockDeleteChatUsersExpectation
	expectations       []*ChatsRepositoryMockDeleteChatUsersExpectation

	callArgs []*ChatsRepositoryMockDeleteChatUsersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsRepositoryMockDeleteChatUsersExpectation specifies expectation struct of the ChatsRepository.DeleteChatUsers
type ChatsRepositoryMockDeleteChatUsersExpectation struct {
	mock      *ChatsRepositoryMock
	params    *ChatsRepositoryMockDeleteChatUsersParams
	paramPtrs *ChatsRepositoryMockDeleteChatUsersParamPtrs
	results   *ChatsRepositoryMockDeleteChatUsersResults
	Counter   uint64
}

// ChatsRepositoryMockDeleteChatUsersParams contains parameters of the ChatsRepository.DeleteChatUsers
type ChatsRepositoryMockDeleteChatUsersParams struct {
	ctx    context.Context
	chatID int64
}

// ChatsRepositoryMockDeleteChatUsersParamPtrs contains pointers to parameters of the ChatsRepository.DeleteChatUsers
type ChatsRepositoryMockDeleteChatUsersParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatsRepositoryMockDeleteChatUsersResults contains results of the ChatsRepository.DeleteChatUsers
type ChatsRepositoryMockDeleteChatUsersResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Optional() *mChatsRepositoryMockDeleteChatUsers {
	mmDeleteChatUsers.optional = true
	return mmDeleteChatUsers
}

// Expect sets up expected params for ChatsRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Expect(ctx context.Context, chatID int64) *mChatsRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatsRepositoryMockDeleteChatUsersExpectation{}
	}

	if mmDeleteChatUsers.defaultExpectation.paramPtrs != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by ExpectParams functions")
	}

	mmDeleteChatUsers.defaultExpectation.params = &ChatsRepositoryMockDeleteChatUsersParams{ctx, chatID}
	for _, e := range mmDeleteChatUsers.expectations {
		if minimock.Equal(e.params, mmDeleteChatUsers.defaultExpectation.params) {
			mmDeleteChatUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatUsers.defaultExpectation.params)
		}
	}

	return mmDeleteChatUsers
}

// ExpectCtxParam1 sets up expected param ctx for ChatsRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) ExpectCtxParam1(ctx context.Context) *mChatsRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatsRepositoryMockDeleteChatUsersExpectation{}
	}

	if mmDeleteChatUsers.defaultExpectation.params != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Expect")
	}

	if mmDeleteChatUsers.defaultExpectation.paramPtrs == nil {
		mmDeleteChatUsers.defaultExpectation.paramPtrs = &ChatsRepositoryMockDeleteChatUsersParamPtrs{}
	}
	mmDeleteChatUsers.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChatUsers
}

// ExpectChatIDParam2 sets up expected param chatID for ChatsRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) ExpectChatIDParam2(chatID int64) *mChatsRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatsRepositoryMockDeleteChatUsersExpectation{}
	}

	if mmDeleteChatUsers.defaultExpectation.params != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Expect")
	}

	if mmDeleteChatUsers.defaultExpectation.paramPtrs == nil {
		mmDeleteChatUsers.defaultExpectation.paramPtrs = &ChatsRepositoryMockDeleteChatUsersParamPtrs{}
	}
	mmDeleteChatUsers.defaultExpectation.paramPtrs.chatID = &chatID

	return mmDeleteChatUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatsRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Inspect(f func(ctx context.Context, chatID int64)) *mChatsRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.inspectFuncDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("Inspect function is already set for ChatsRepositoryMock.DeleteChatUsers")
	}

	mmDeleteChatUsers.mock.inspectFuncDeleteChatUsers = f

	return mmDeleteChatUsers
}

// Return sets up results that will be returned by ChatsRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Return(err error) *ChatsRepositoryMock {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatsRepositoryMockDeleteChatUsersExpectation{mock: mmDeleteChatUsers.mock}
	}
	mmDeleteChatUsers.defaultExpectation.results = &ChatsRepositoryMockDeleteChatUsersResults{err}
	return mmDeleteChatUsers.mock
}

// Set uses given function f to mock the ChatsRepository.DeleteChatUsers method
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatsRepositoryMock {
	if mmDeleteChatUsers.defaultExpectation != nil {
		mmDeleteChatUsers.mock.t.Fatalf("Default expectation is already set for the ChatsRepository.DeleteChatUsers method")
	}

	if len(mmDeleteChatUsers.expectations) > 0 {
		mmDeleteChatUsers.mock.t.Fatalf("Some expectations are already set for the ChatsRepository.DeleteChatUsers method")
	}

	mmDeleteChatUsers.mock.funcDeleteChatUsers = f
	return mmDeleteChatUsers.mock
}

// When sets expectation for the ChatsRepository.DeleteChatUsers which will trigger the result defined by the following
// Then helper
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) When(ctx context.Context, chatID int64) *ChatsRepositoryMockDeleteChatUsersExpectation {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatsRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	expectation := &ChatsRepositoryMockDeleteChatUsersExpectation{
		mock:   mmDeleteChatUsers.mock,
		params: &ChatsRepositoryMockDeleteChatUsersParams{ctx, chatID},
	}
	mmDeleteChatUsers.expectations = append(mmDeleteChatUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatsRepository.DeleteChatUsers return parameters for the expectation previously defined by the When method
func (e *ChatsRepositoryMockDeleteChatUsersExpectation) Then(err error) *ChatsRepositoryMock {
	e.results = &ChatsRepositoryMockDeleteChatUsersResults{err}
	return e.mock
}

// Times sets number of times ChatsRepository.DeleteChatUsers should be invoked
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Times(n uint64) *mChatsRepositoryMockDeleteChatUsers {
	if n == 0 {
		mmDeleteChatUsers.mock.t.Fatalf("Times of ChatsRepositoryMock.DeleteChatUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChatUsers.expectedInvocations, n)
	return mmDeleteChatUsers
}

func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) invocationsDone() bool {
	if len(mmDeleteChatUsers.expectations) == 0 && mmDeleteChatUsers.defaultExpectation == nil && mmDeleteChatUsers.mock.funcDeleteChatUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChatUsers.mock.afterDeleteChatUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChatUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChatUsers implements repository.ChatsRepository
func (mmDeleteChatUsers *ChatsRepositoryMock) DeleteChatUsers(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatUsers.beforeDeleteChatUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatUsers.afterDeleteChatUsersCounter, 1)

	if mmDeleteChatUsers.inspectFuncDeleteChatUsers != nil {
		mmDeleteChatUsers.inspectFuncDeleteChatUsers(ctx, chatID)
	}

	mm_params := ChatsRepositoryMockDeleteChatUsersParams{ctx, chatID}

	// Record call args
	mmDeleteChatUsers.DeleteChatUsersMock.mutex.Lock()
	mmDeleteChatUsers.DeleteChatUsersMock.callArgs = append(mmDeleteChatUsers.DeleteChatUsersMock.callArgs, &mm_params)
	mmDeleteChatUsers.DeleteChatUsersMock.mutex.Unlock()

	for _, e := range mmDeleteChatUsers.DeleteChatUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.paramPtrs

		mm_got := ChatsRepositoryMockDeleteChatUsersParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChatUsers.t.Errorf("ChatsRepositoryMock.DeleteChatUsers got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteChatUsers.t.Errorf("ChatsRepositoryMock.DeleteChatUsers got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatUsers.t.Errorf("ChatsRepositoryMock.DeleteChatUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatUsers.t.Fatal("No results are set for the ChatsRepositoryMock.DeleteChatUsers")
		}
		return (*mm_results).err
	}
	if mmDeleteChatUsers.funcDeleteChatUsers != nil {
		return mmDeleteChatUsers.funcDeleteChatUsers(ctx, chatID)
	}
	mmDeleteChatUsers.t.Fatalf("Unexpected call to ChatsRepositoryMock.DeleteChatUsers. %v %v", ctx, chatID)
	return
}

// DeleteChatUsersAfterCounter returns a count of finished ChatsRepositoryMock.DeleteChatUsers invocations
func (mmDeleteChatUsers *ChatsRepositoryMock) DeleteChatUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatUsers.afterDeleteChatUsersCounter)
}

// DeleteChatUsersBeforeCounter returns a count of ChatsRepositoryMock.DeleteChatUsers invocations
func (mmDeleteChatUsers *ChatsRepositoryMock) DeleteChatUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatUsers.beforeDeleteChatUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatsRepositoryMock.DeleteChatUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatUsers *mChatsRepositoryMockDeleteChatUsers) Calls() []*ChatsRepositoryMockDeleteChatUsersParams {
	mmDeleteChatUsers.mutex.RLock()

	argCopy := make([]*ChatsRepositoryMockDeleteChatUsersParams, len(mmDeleteChatUsers.callArgs))
	copy(argCopy, mmDeleteChatUsers.callArgs)

	mmDeleteChatUsers.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatUsersDone returns true if the count of the DeleteChatUsers invocations corresponds
// the number of defined expectations
func (m *ChatsRepositoryMock) MinimockDeleteChatUsersDone() bool {
	if m.DeleteChatUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatUsersMock.invocationsDone()
}

// MinimockDeleteChatUsersInspect logs each unmet expectation
func (m *ChatsRepositoryMock) MinimockDeleteChatUsersInspect() {
	for _, e := range m.DeleteChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsRepositoryMock.DeleteChatUsers with params: %#v", *e.params)
		}
	}

	afterDeleteChatUsersCounter := mm_atomic.LoadUint64(&m.afterDeleteChatUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatUsersMock.defaultExpectation != nil && afterDeleteChatUsersCounter < 1 {
		if m.DeleteChatUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsRepositoryMock.DeleteChatUsers")
		} else {
			m.t.Errorf("Expected call to ChatsRepositoryMock.DeleteChatUsers with params: %#v", *m.DeleteChatUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatUsers != nil && afterDeleteChatUsersCounter < 1 {
		m.t.Error("Expected call to ChatsRepositoryMock.DeleteChatUsers")
	}

	if !m.DeleteChatUsersMock.invocationsDone() && afterDeleteChatUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsRepositoryMock.DeleteChatUsers but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatUsersMock.expectedInvocations), afterDeleteChatUsersCounter)
	}
}

type mChatsRepositoryMockGetChatUserID struct {
	optional           bool
	mock               *ChatsRepositoryMock
	defaultExpectation *ChatsRepositoryMockGetChatUserIDExpectation
	expectations       []*ChatsRepositoryMockGetChatUserIDExpectation

	callArgs []*ChatsRepositoryMockGetChatUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsRepositoryMockGetChatUserIDExpectation specifies expectation struct of the ChatsRepository.GetChatUserID
type ChatsRepositoryMockGetChatUserIDExpectation struct {
	mock      *ChatsRepositoryMock
	params    *ChatsRepositoryMockGetChatUserIDParams
	paramPtrs *ChatsRepositoryMockGetChatUserIDParamPtrs
	results   *ChatsRepositoryMockGetChatUserIDResults
	Counter   uint64
}

// ChatsRepositoryMockGetChatUserIDParams contains parameters of the ChatsRepository.GetChatUserID
type ChatsRepositoryMockGetChatUserIDParams struct {
	ctx    context.Context
	chatID int64
	userID int64
}

// ChatsRepositoryMockGetChatUserIDParamPtrs contains pointers to parameters of the ChatsRepository.GetChatUserID
type ChatsRepositoryMockGetChatUserIDParamPtrs struct {
	ctx    *context.Context
	chatID *int64
	userID *int64
}

// ChatsRepositoryMockGetChatUserIDResults contains results of the ChatsRepository.GetChatUserID
type ChatsRepositoryMockGetChatUserIDResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Optional() *mChatsRepositoryMockGetChatUserID {
	mmGetChatUserID.optional = true
	return mmGetChatUserID
}

// Expect sets up expected params for ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Expect(ctx context.Context, chatID int64, userID int64) *mChatsRepositoryMockGetChatUserID {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	if mmGetChatUserID.defaultExpectation == nil {
		mmGetChatUserID.defaultExpectation = &ChatsRepositoryMockGetChatUserIDExpectation{}
	}

	if mmGetChatUserID.defaultExpectation.paramPtrs != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by ExpectParams functions")
	}

	mmGetChatUserID.defaultExpectation.params = &ChatsRepositoryMockGetChatUserIDParams{ctx, chatID, userID}
	for _, e := range mmGetChatUserID.expectations {
		if minimock.Equal(e.params, mmGetChatUserID.defaultExpectation.params) {
			mmGetChatUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatUserID.defaultExpectation.params)
		}
	}

	return mmGetChatUserID
}

// ExpectCtxParam1 sets up expected param ctx for ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) ExpectCtxParam1(ctx context.Context) *mChatsRepositoryMockGetChatUserID {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	if mmGetChatUserID.defaultExpectation == nil {
		mmGetChatUserID.defaultExpectation = &ChatsRepositoryMockGetChatUserIDExpectation{}
	}

	if mmGetChatUserID.defaultExpectation.params != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Expect")
	}

	if mmGetChatUserID.defaultExpectation.paramPtrs == nil {
		mmGetChatUserID.defaultExpectation.paramPtrs = &ChatsRepositoryMockGetChatUserIDParamPtrs{}
	}
	mmGetChatUserID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetChatUserID
}

// ExpectChatIDParam2 sets up expected param chatID for ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) ExpectChatIDParam2(chatID int64) *mChatsRepositoryMockGetChatUserID {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	if mmGetChatUserID.defaultExpectation == nil {
		mmGetChatUserID.defaultExpectation = &ChatsRepositoryMockGetChatUserIDExpectation{}
	}

	if mmGetChatUserID.defaultExpectation.params != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Expect")
	}

	if mmGetChatUserID.defaultExpectation.paramPtrs == nil {
		mmGetChatUserID.defaultExpectation.paramPtrs = &ChatsRepositoryMockGetChatUserIDParamPtrs{}
	}
	mmGetChatUserID.defaultExpectation.paramPtrs.chatID = &chatID

	return mmGetChatUserID
}

// ExpectUserIDParam3 sets up expected param userID for ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) ExpectUserIDParam3(userID int64) *mChatsRepositoryMockGetChatUserID {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	if mmGetChatUserID.defaultExpectation == nil {
		mmGetChatUserID.defaultExpectation = &ChatsRepositoryMockGetChatUserIDExpectation{}
	}

	if mmGetChatUserID.defaultExpectation.params != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Expect")
	}

	if mmGetChatUserID.defaultExpectation.paramPtrs == nil {
		mmGetChatUserID.defaultExpectation.paramPtrs = &ChatsRepositoryMockGetChatUserIDParamPtrs{}
	}
	mmGetChatUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmGetChatUserID
}

// Inspect accepts an inspector function that has same arguments as the ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Inspect(f func(ctx context.Context, chatID int64, userID int64)) *mChatsRepositoryMockGetChatUserID {
	if mmGetChatUserID.mock.inspectFuncGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("Inspect function is already set for ChatsRepositoryMock.GetChatUserID")
	}

	mmGetChatUserID.mock.inspectFuncGetChatUserID = f

	return mmGetChatUserID
}

// Return sets up results that will be returned by ChatsRepository.GetChatUserID
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Return(i1 int64, err error) *ChatsRepositoryMock {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	if mmGetChatUserID.defaultExpectation == nil {
		mmGetChatUserID.defaultExpectation = &ChatsRepositoryMockGetChatUserIDExpectation{mock: mmGetChatUserID.mock}
	}
	mmGetChatUserID.defaultExpectation.results = &ChatsRepositoryMockGetChatUserIDResults{i1, err}
	return mmGetChatUserID.mock
}

// Set uses given function f to mock the ChatsRepository.GetChatUserID method
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Set(f func(ctx context.Context, chatID int64, userID int64) (i1 int64, err error)) *ChatsRepositoryMock {
	if mmGetChatUserID.defaultExpectation != nil {
		mmGetChatUserID.mock.t.Fatalf("Default expectation is already set for the ChatsRepository.GetChatUserID method")
	}

	if len(mmGetChatUserID.expectations) > 0 {
		mmGetChatUserID.mock.t.Fatalf("Some expectations are already set for the ChatsRepository.GetChatUserID method")
	}

	mmGetChatUserID.mock.funcGetChatUserID = f
	return mmGetChatUserID.mock
}

// When sets expectation for the ChatsRepository.GetChatUserID which will trigger the result defined by the following
// Then helper
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) When(ctx context.Context, chatID int64, userID int64) *ChatsRepositoryMockGetChatUserIDExpectation {
	if mmGetChatUserID.mock.funcGetChatUserID != nil {
		mmGetChatUserID.mock.t.Fatalf("ChatsRepositoryMock.GetChatUserID mock is already set by Set")
	}

	expectation := &ChatsRepositoryMockGetChatUserIDExpectation{
		mock:   mmGetChatUserID.mock,
		params: &ChatsRepositoryMockGetChatUserIDParams{ctx, chatID, userID},
	}
	mmGetChatUserID.expectations = append(mmGetChatUserID.expectations, expectation)
	return expectation
}

// Then sets up ChatsRepository.GetChatUserID return parameters for the expectation previously defined by the When method
func (e *ChatsRepositoryMockGetChatUserIDExpectation) Then(i1 int64, err error) *ChatsRepositoryMock {
	e.results = &ChatsRepositoryMockGetChatUserIDResults{i1, err}
	return e.mock
}

// Times sets number of times ChatsRepository.GetChatUserID should be invoked
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Times(n uint64) *mChatsRepositoryMockGetChatUserID {
	if n == 0 {
		mmGetChatUserID.mock.t.Fatalf("Times of ChatsRepositoryMock.GetChatUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatUserID.expectedInvocations, n)
	return mmGetChatUserID
}

func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) invocationsDone() bool {
	if len(mmGetChatUserID.expectations) == 0 && mmGetChatUserID.defaultExpectation == nil && mmGetChatUserID.mock.funcGetChatUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatUserID.mock.afterGetChatUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatUserID implements repository.ChatsRepository
func (mmGetChatUserID *ChatsRepositoryMock) GetChatUserID(ctx context.Context, chatID int64, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetChatUserID.beforeGetChatUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatUserID.afterGetChatUserIDCounter, 1)

	if mmGetChatUserID.inspectFuncGetChatUserID != nil {
		mmGetChatUserID.inspectFuncGetChatUserID(ctx, chatID, userID)
	}

	mm_params := ChatsRepositoryMockGetChatUserIDParams{ctx, chatID, userID}

	// Record call args
	mmGetChatUserID.GetChatUserIDMock.mutex.Lock()
	mmGetChatUserID.GetChatUserIDMock.callArgs = append(mmGetChatUserID.GetChatUserIDMock.callArgs, &mm_params)
	mmGetChatUserID.GetChatUserIDMock.mutex.Unlock()

	for _, e := range mmGetChatUserID.GetChatUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetChatUserID.GetChatUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatUserID.GetChatUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatUserID.GetChatUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatUserID.GetChatUserIDMock.defaultExpectation.paramPtrs

		mm_got := ChatsRepositoryMockGetChatUserIDParams{ctx, chatID, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatUserID.t.Errorf("ChatsRepositoryMock.GetChatUserID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetChatUserID.t.Errorf("ChatsRepositoryMock.GetChatUserID got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetChatUserID.t.Errorf("ChatsRepositoryMock.GetChatUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatUserID.t.Errorf("ChatsRepositoryMock.GetChatUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatUserID.GetChatUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatUserID.t.Fatal("No results are set for the ChatsRepositoryMock.GetChatUserID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetChatUserID.funcGetChatUserID != nil {
		return mmGetChatUserID.funcGetChatUserID(ctx, chatID, userID)
	}
	mmGetChatUserID.t.Fatalf("Unexpected call to ChatsRepositoryMock.GetChatUserID. %v %v %v", ctx, chatID, userID)
	return
}

// GetChatUserIDAfterCounter returns a count of finished ChatsRepositoryMock.GetChatUserID invocations
func (mmGetChatUserID *ChatsRepositoryMock) GetChatUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatUserID.afterGetChatUserIDCounter)
}

// GetChatUserIDBeforeCounter returns a count of ChatsRepositoryMock.GetChatUserID invocations
func (mmGetChatUserID *ChatsRepositoryMock) GetChatUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatUserID.beforeGetChatUserIDCounter)
}

// Calls returns a list of arguments used in each call to ChatsRepositoryMock.GetChatUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatUserID *mChatsRepositoryMockGetChatUserID) Calls() []*ChatsRepositoryMockGetChatUserIDParams {
	mmGetChatUserID.mutex.RLock()

	argCopy := make([]*ChatsRepositoryMockGetChatUserIDParams, len(mmGetChatUserID.callArgs))
	copy(argCopy, mmGetChatUserID.callArgs)

	mmGetChatUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatUserIDDone returns true if the count of the GetChatUserID invocations corresponds
// the number of defined expectations
func (m *ChatsRepositoryMock) MinimockGetChatUserIDDone() bool {
	if m.GetChatUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatUserIDMock.invocationsDone()
}

// MinimockGetChatUserIDInspect logs each unmet expectation
func (m *ChatsRepositoryMock) MinimockGetChatUserIDInspect() {
	for _, e := range m.GetChatUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsRepositoryMock.GetChatUserID with params: %#v", *e.params)
		}
	}

	afterGetChatUserIDCounter := mm_atomic.LoadUint64(&m.afterGetChatUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatUserIDMock.defaultExpectation != nil && afterGetChatUserIDCounter < 1 {
		if m.GetChatUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsRepositoryMock.GetChatUserID")
		} else {
			m.t.Errorf("Expected call to ChatsRepositoryMock.GetChatUserID with params: %#v", *m.GetChatUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatUserID != nil && afterGetChatUserIDCounter < 1 {
		m.t.Error("Expected call to ChatsRepositoryMock.GetChatUserID")
	}

	if !m.GetChatUserIDMock.invocationsDone() && afterGetChatUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsRepositoryMock.GetChatUserID but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatUserIDMock.expectedInvocations), afterGetChatUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateChatUsersInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteChatUsersInspect()

			m.MinimockGetChatUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateChatUsersDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteChatUsersDone() &&
		m.MinimockGetChatUserIDDone()
}
