// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ukrainskykirill/chat-server/internal/service.StreamService -o stream_service_mock_test.go -n StreamServiceMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"

	"github.com/ukrainskykirill/chat-server/internal/model"
)

// StreamServiceMock implements StreamService
type StreamServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddMessageToChat          func(ctx context.Context, msgIn *model.MessageIn)
	inspectFuncAddMessageToChat   func(ctx context.Context, msgIn *model.MessageIn)
	afterAddMessageToChatCounter  uint64
	beforeAddMessageToChatCounter uint64
	AddMessageToChatMock          mStreamServiceMockAddMessageToChat

	funcAddStreamByUserID          func(connectInfo *model.ConnectInfo)
	inspectFuncAddStreamByUserID   func(connectInfo *model.ConnectInfo)
	afterAddStreamByUserIDCounter  uint64
	beforeAddStreamByUserIDCounter uint64
	AddStreamByUserIDMock          mStreamServiceMockAddStreamByUserID

	funcAddToChannel          func(ctx context.Context, chatID int64)
	inspectFuncAddToChannel   func(ctx context.Context, chatID int64)
	afterAddToChannelCounter  uint64
	beforeAddToChannelCounter uint64
	AddToChannelMock          mStreamServiceMockAddToChannel

	funcDeleteStreamByUserID          func(chatID string, userID string)
	inspectFuncDeleteStreamByUserID   func(chatID string, userID string)
	afterDeleteStreamByUserIDCounter  uint64
	beforeDeleteStreamByUserIDCounter uint64
	DeleteStreamByUserIDMock          mStreamServiceMockDeleteStreamByUserID

	funcGetChatChannel          func(ctx context.Context, chatID string) (ch1 chan *model.StreamMessage, err error)
	inspectFuncGetChatChannel   func(ctx context.Context, chatID string)
	afterGetChatChannelCounter  uint64
	beforeGetChatChannelCounter uint64
	GetChatChannelMock          mStreamServiceMockGetChatChannel

	funcSendMessageToStreams          func(chatID string, msg *model.StreamMessage) (err error)
	inspectFuncSendMessageToStreams   func(chatID string, msg *model.StreamMessage)
	afterSendMessageToStreamsCounter  uint64
	beforeSendMessageToStreamsCounter uint64
	SendMessageToStreamsMock          mStreamServiceMockSendMessageToStreams
}

// NewStreamServiceMock returns a mock for StreamService
func NewStreamServiceMock(t minimock.Tester) *StreamServiceMock {
	m := &StreamServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMessageToChatMock = mStreamServiceMockAddMessageToChat{mock: m}
	m.AddMessageToChatMock.callArgs = []*StreamServiceMockAddMessageToChatParams{}

	m.AddStreamByUserIDMock = mStreamServiceMockAddStreamByUserID{mock: m}
	m.AddStreamByUserIDMock.callArgs = []*StreamServiceMockAddStreamByUserIDParams{}

	m.AddToChannelMock = mStreamServiceMockAddToChannel{mock: m}
	m.AddToChannelMock.callArgs = []*StreamServiceMockAddToChannelParams{}

	m.DeleteStreamByUserIDMock = mStreamServiceMockDeleteStreamByUserID{mock: m}
	m.DeleteStreamByUserIDMock.callArgs = []*StreamServiceMockDeleteStreamByUserIDParams{}

	m.GetChatChannelMock = mStreamServiceMockGetChatChannel{mock: m}
	m.GetChatChannelMock.callArgs = []*StreamServiceMockGetChatChannelParams{}

	m.SendMessageToStreamsMock = mStreamServiceMockSendMessageToStreams{mock: m}
	m.SendMessageToStreamsMock.callArgs = []*StreamServiceMockSendMessageToStreamsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStreamServiceMockAddMessageToChat struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockAddMessageToChatExpectation
	expectations       []*StreamServiceMockAddMessageToChatExpectation

	callArgs []*StreamServiceMockAddMessageToChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockAddMessageToChatExpectation specifies expectation struct of the StreamService.AddMessageToChat
type StreamServiceMockAddMessageToChatExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockAddMessageToChatParams
	paramPtrs *StreamServiceMockAddMessageToChatParamPtrs

	Counter uint64
}

// StreamServiceMockAddMessageToChatParams contains parameters of the StreamService.AddMessageToChat
type StreamServiceMockAddMessageToChatParams struct {
	ctx   context.Context
	msgIn *model.MessageIn
}

// StreamServiceMockAddMessageToChatParamPtrs contains pointers to parameters of the StreamService.AddMessageToChat
type StreamServiceMockAddMessageToChatParamPtrs struct {
	ctx   *context.Context
	msgIn **model.MessageIn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Optional() *mStreamServiceMockAddMessageToChat {
	mmAddMessageToChat.optional = true
	return mmAddMessageToChat
}

// Expect sets up expected params for StreamService.AddMessageToChat
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Expect(ctx context.Context, msgIn *model.MessageIn) *mStreamServiceMockAddMessageToChat {
	if mmAddMessageToChat.mock.funcAddMessageToChat != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Set")
	}

	if mmAddMessageToChat.defaultExpectation == nil {
		mmAddMessageToChat.defaultExpectation = &StreamServiceMockAddMessageToChatExpectation{}
	}

	if mmAddMessageToChat.defaultExpectation.paramPtrs != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by ExpectParams functions")
	}

	mmAddMessageToChat.defaultExpectation.params = &StreamServiceMockAddMessageToChatParams{ctx, msgIn}
	for _, e := range mmAddMessageToChat.expectations {
		if minimock.Equal(e.params, mmAddMessageToChat.defaultExpectation.params) {
			mmAddMessageToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageToChat.defaultExpectation.params)
		}
	}

	return mmAddMessageToChat
}

// ExpectCtxParam1 sets up expected param ctx for StreamService.AddMessageToChat
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) ExpectCtxParam1(ctx context.Context) *mStreamServiceMockAddMessageToChat {
	if mmAddMessageToChat.mock.funcAddMessageToChat != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Set")
	}

	if mmAddMessageToChat.defaultExpectation == nil {
		mmAddMessageToChat.defaultExpectation = &StreamServiceMockAddMessageToChatExpectation{}
	}

	if mmAddMessageToChat.defaultExpectation.params != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Expect")
	}

	if mmAddMessageToChat.defaultExpectation.paramPtrs == nil {
		mmAddMessageToChat.defaultExpectation.paramPtrs = &StreamServiceMockAddMessageToChatParamPtrs{}
	}
	mmAddMessageToChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddMessageToChat
}

// ExpectMsgInParam2 sets up expected param msgIn for StreamService.AddMessageToChat
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) ExpectMsgInParam2(msgIn *model.MessageIn) *mStreamServiceMockAddMessageToChat {
	if mmAddMessageToChat.mock.funcAddMessageToChat != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Set")
	}

	if mmAddMessageToChat.defaultExpectation == nil {
		mmAddMessageToChat.defaultExpectation = &StreamServiceMockAddMessageToChatExpectation{}
	}

	if mmAddMessageToChat.defaultExpectation.params != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Expect")
	}

	if mmAddMessageToChat.defaultExpectation.paramPtrs == nil {
		mmAddMessageToChat.defaultExpectation.paramPtrs = &StreamServiceMockAddMessageToChatParamPtrs{}
	}
	mmAddMessageToChat.defaultExpectation.paramPtrs.msgIn = &msgIn

	return mmAddMessageToChat
}

// Inspect accepts an inspector function that has same arguments as the StreamService.AddMessageToChat
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Inspect(f func(ctx context.Context, msgIn *model.MessageIn)) *mStreamServiceMockAddMessageToChat {
	if mmAddMessageToChat.mock.inspectFuncAddMessageToChat != nil {
		mmAddMessageToChat.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.AddMessageToChat")
	}

	mmAddMessageToChat.mock.inspectFuncAddMessageToChat = f

	return mmAddMessageToChat
}

// Return sets up results that will be returned by StreamService.AddMessageToChat
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Return() *StreamServiceMock {
	if mmAddMessageToChat.mock.funcAddMessageToChat != nil {
		mmAddMessageToChat.mock.t.Fatalf("StreamServiceMock.AddMessageToChat mock is already set by Set")
	}

	if mmAddMessageToChat.defaultExpectation == nil {
		mmAddMessageToChat.defaultExpectation = &StreamServiceMockAddMessageToChatExpectation{mock: mmAddMessageToChat.mock}
	}

	return mmAddMessageToChat.mock
}

// Set uses given function f to mock the StreamService.AddMessageToChat method
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Set(f func(ctx context.Context, msgIn *model.MessageIn)) *StreamServiceMock {
	if mmAddMessageToChat.defaultExpectation != nil {
		mmAddMessageToChat.mock.t.Fatalf("Default expectation is already set for the StreamService.AddMessageToChat method")
	}

	if len(mmAddMessageToChat.expectations) > 0 {
		mmAddMessageToChat.mock.t.Fatalf("Some expectations are already set for the StreamService.AddMessageToChat method")
	}

	mmAddMessageToChat.mock.funcAddMessageToChat = f
	return mmAddMessageToChat.mock
}

// Times sets number of times StreamService.AddMessageToChat should be invoked
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Times(n uint64) *mStreamServiceMockAddMessageToChat {
	if n == 0 {
		mmAddMessageToChat.mock.t.Fatalf("Times of StreamServiceMock.AddMessageToChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddMessageToChat.expectedInvocations, n)
	return mmAddMessageToChat
}

func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) invocationsDone() bool {
	if len(mmAddMessageToChat.expectations) == 0 && mmAddMessageToChat.defaultExpectation == nil && mmAddMessageToChat.mock.funcAddMessageToChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddMessageToChat.mock.afterAddMessageToChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddMessageToChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddMessageToChat implements StreamService
func (mmAddMessageToChat *StreamServiceMock) AddMessageToChat(ctx context.Context, msgIn *model.MessageIn) {
	mm_atomic.AddUint64(&mmAddMessageToChat.beforeAddMessageToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageToChat.afterAddMessageToChatCounter, 1)

	if mmAddMessageToChat.inspectFuncAddMessageToChat != nil {
		mmAddMessageToChat.inspectFuncAddMessageToChat(ctx, msgIn)
	}

	mm_params := StreamServiceMockAddMessageToChatParams{ctx, msgIn}

	// Record call args
	mmAddMessageToChat.AddMessageToChatMock.mutex.Lock()
	mmAddMessageToChat.AddMessageToChatMock.callArgs = append(mmAddMessageToChat.AddMessageToChatMock.callArgs, &mm_params)
	mmAddMessageToChat.AddMessageToChatMock.mutex.Unlock()

	for _, e := range mmAddMessageToChat.AddMessageToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddMessageToChat.AddMessageToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageToChat.AddMessageToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageToChat.AddMessageToChatMock.defaultExpectation.params
		mm_want_ptrs := mmAddMessageToChat.AddMessageToChatMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockAddMessageToChatParams{ctx, msgIn}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddMessageToChat.t.Errorf("StreamServiceMock.AddMessageToChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msgIn != nil && !minimock.Equal(*mm_want_ptrs.msgIn, mm_got.msgIn) {
				mmAddMessageToChat.t.Errorf("StreamServiceMock.AddMessageToChat got unexpected parameter msgIn, want: %#v, got: %#v%s\n", *mm_want_ptrs.msgIn, mm_got.msgIn, minimock.Diff(*mm_want_ptrs.msgIn, mm_got.msgIn))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageToChat.t.Errorf("StreamServiceMock.AddMessageToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddMessageToChat.funcAddMessageToChat != nil {
		mmAddMessageToChat.funcAddMessageToChat(ctx, msgIn)
		return
	}
	mmAddMessageToChat.t.Fatalf("Unexpected call to StreamServiceMock.AddMessageToChat. %v %v", ctx, msgIn)

}

// AddMessageToChatAfterCounter returns a count of finished StreamServiceMock.AddMessageToChat invocations
func (mmAddMessageToChat *StreamServiceMock) AddMessageToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToChat.afterAddMessageToChatCounter)
}

// AddMessageToChatBeforeCounter returns a count of StreamServiceMock.AddMessageToChat invocations
func (mmAddMessageToChat *StreamServiceMock) AddMessageToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToChat.beforeAddMessageToChatCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.AddMessageToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageToChat *mStreamServiceMockAddMessageToChat) Calls() []*StreamServiceMockAddMessageToChatParams {
	mmAddMessageToChat.mutex.RLock()

	argCopy := make([]*StreamServiceMockAddMessageToChatParams, len(mmAddMessageToChat.callArgs))
	copy(argCopy, mmAddMessageToChat.callArgs)

	mmAddMessageToChat.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageToChatDone returns true if the count of the AddMessageToChat invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockAddMessageToChatDone() bool {
	if m.AddMessageToChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMessageToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMessageToChatMock.invocationsDone()
}

// MinimockAddMessageToChatInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockAddMessageToChatInspect() {
	for _, e := range m.AddMessageToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.AddMessageToChat with params: %#v", *e.params)
		}
	}

	afterAddMessageToChatCounter := mm_atomic.LoadUint64(&m.afterAddMessageToChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageToChatMock.defaultExpectation != nil && afterAddMessageToChatCounter < 1 {
		if m.AddMessageToChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.AddMessageToChat")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.AddMessageToChat with params: %#v", *m.AddMessageToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageToChat != nil && afterAddMessageToChatCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.AddMessageToChat")
	}

	if !m.AddMessageToChatMock.invocationsDone() && afterAddMessageToChatCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.AddMessageToChat but found %d calls",
			mm_atomic.LoadUint64(&m.AddMessageToChatMock.expectedInvocations), afterAddMessageToChatCounter)
	}
}

type mStreamServiceMockAddStreamByUserID struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockAddStreamByUserIDExpectation
	expectations       []*StreamServiceMockAddStreamByUserIDExpectation

	callArgs []*StreamServiceMockAddStreamByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockAddStreamByUserIDExpectation specifies expectation struct of the StreamService.AddStreamByUserID
type StreamServiceMockAddStreamByUserIDExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockAddStreamByUserIDParams
	paramPtrs *StreamServiceMockAddStreamByUserIDParamPtrs

	Counter uint64
}

// StreamServiceMockAddStreamByUserIDParams contains parameters of the StreamService.AddStreamByUserID
type StreamServiceMockAddStreamByUserIDParams struct {
	connectInfo *model.ConnectInfo
}

// StreamServiceMockAddStreamByUserIDParamPtrs contains pointers to parameters of the StreamService.AddStreamByUserID
type StreamServiceMockAddStreamByUserIDParamPtrs struct {
	connectInfo **model.ConnectInfo
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Optional() *mStreamServiceMockAddStreamByUserID {
	mmAddStreamByUserID.optional = true
	return mmAddStreamByUserID
}

// Expect sets up expected params for StreamService.AddStreamByUserID
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Expect(connectInfo *model.ConnectInfo) *mStreamServiceMockAddStreamByUserID {
	if mmAddStreamByUserID.mock.funcAddStreamByUserID != nil {
		mmAddStreamByUserID.mock.t.Fatalf("StreamServiceMock.AddStreamByUserID mock is already set by Set")
	}

	if mmAddStreamByUserID.defaultExpectation == nil {
		mmAddStreamByUserID.defaultExpectation = &StreamServiceMockAddStreamByUserIDExpectation{}
	}

	if mmAddStreamByUserID.defaultExpectation.paramPtrs != nil {
		mmAddStreamByUserID.mock.t.Fatalf("StreamServiceMock.AddStreamByUserID mock is already set by ExpectParams functions")
	}

	mmAddStreamByUserID.defaultExpectation.params = &StreamServiceMockAddStreamByUserIDParams{connectInfo}
	for _, e := range mmAddStreamByUserID.expectations {
		if minimock.Equal(e.params, mmAddStreamByUserID.defaultExpectation.params) {
			mmAddStreamByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddStreamByUserID.defaultExpectation.params)
		}
	}

	return mmAddStreamByUserID
}

// ExpectConnectInfoParam1 sets up expected param connectInfo for StreamService.AddStreamByUserID
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) ExpectConnectInfoParam1(connectInfo *model.ConnectInfo) *mStreamServiceMockAddStreamByUserID {
	if mmAddStreamByUserID.mock.funcAddStreamByUserID != nil {
		mmAddStreamByUserID.mock.t.Fatalf("StreamServiceMock.AddStreamByUserID mock is already set by Set")
	}

	if mmAddStreamByUserID.defaultExpectation == nil {
		mmAddStreamByUserID.defaultExpectation = &StreamServiceMockAddStreamByUserIDExpectation{}
	}

	if mmAddStreamByUserID.defaultExpectation.params != nil {
		mmAddStreamByUserID.mock.t.Fatalf("StreamServiceMock.AddStreamByUserID mock is already set by Expect")
	}

	if mmAddStreamByUserID.defaultExpectation.paramPtrs == nil {
		mmAddStreamByUserID.defaultExpectation.paramPtrs = &StreamServiceMockAddStreamByUserIDParamPtrs{}
	}
	mmAddStreamByUserID.defaultExpectation.paramPtrs.connectInfo = &connectInfo

	return mmAddStreamByUserID
}

// Inspect accepts an inspector function that has same arguments as the StreamService.AddStreamByUserID
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Inspect(f func(connectInfo *model.ConnectInfo)) *mStreamServiceMockAddStreamByUserID {
	if mmAddStreamByUserID.mock.inspectFuncAddStreamByUserID != nil {
		mmAddStreamByUserID.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.AddStreamByUserID")
	}

	mmAddStreamByUserID.mock.inspectFuncAddStreamByUserID = f

	return mmAddStreamByUserID
}

// Return sets up results that will be returned by StreamService.AddStreamByUserID
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Return() *StreamServiceMock {
	if mmAddStreamByUserID.mock.funcAddStreamByUserID != nil {
		mmAddStreamByUserID.mock.t.Fatalf("StreamServiceMock.AddStreamByUserID mock is already set by Set")
	}

	if mmAddStreamByUserID.defaultExpectation == nil {
		mmAddStreamByUserID.defaultExpectation = &StreamServiceMockAddStreamByUserIDExpectation{mock: mmAddStreamByUserID.mock}
	}

	return mmAddStreamByUserID.mock
}

// Set uses given function f to mock the StreamService.AddStreamByUserID method
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Set(f func(connectInfo *model.ConnectInfo)) *StreamServiceMock {
	if mmAddStreamByUserID.defaultExpectation != nil {
		mmAddStreamByUserID.mock.t.Fatalf("Default expectation is already set for the StreamService.AddStreamByUserID method")
	}

	if len(mmAddStreamByUserID.expectations) > 0 {
		mmAddStreamByUserID.mock.t.Fatalf("Some expectations are already set for the StreamService.AddStreamByUserID method")
	}

	mmAddStreamByUserID.mock.funcAddStreamByUserID = f
	return mmAddStreamByUserID.mock
}

// Times sets number of times StreamService.AddStreamByUserID should be invoked
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Times(n uint64) *mStreamServiceMockAddStreamByUserID {
	if n == 0 {
		mmAddStreamByUserID.mock.t.Fatalf("Times of StreamServiceMock.AddStreamByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddStreamByUserID.expectedInvocations, n)
	return mmAddStreamByUserID
}

func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) invocationsDone() bool {
	if len(mmAddStreamByUserID.expectations) == 0 && mmAddStreamByUserID.defaultExpectation == nil && mmAddStreamByUserID.mock.funcAddStreamByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddStreamByUserID.mock.afterAddStreamByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddStreamByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddStreamByUserID implements StreamService
func (mmAddStreamByUserID *StreamServiceMock) AddStreamByUserID(connectInfo *model.ConnectInfo) {
	mm_atomic.AddUint64(&mmAddStreamByUserID.beforeAddStreamByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmAddStreamByUserID.afterAddStreamByUserIDCounter, 1)

	if mmAddStreamByUserID.inspectFuncAddStreamByUserID != nil {
		mmAddStreamByUserID.inspectFuncAddStreamByUserID(connectInfo)
	}

	mm_params := StreamServiceMockAddStreamByUserIDParams{connectInfo}

	// Record call args
	mmAddStreamByUserID.AddStreamByUserIDMock.mutex.Lock()
	mmAddStreamByUserID.AddStreamByUserIDMock.callArgs = append(mmAddStreamByUserID.AddStreamByUserIDMock.callArgs, &mm_params)
	mmAddStreamByUserID.AddStreamByUserIDMock.mutex.Unlock()

	for _, e := range mmAddStreamByUserID.AddStreamByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddStreamByUserID.AddStreamByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddStreamByUserID.AddStreamByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmAddStreamByUserID.AddStreamByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmAddStreamByUserID.AddStreamByUserIDMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockAddStreamByUserIDParams{connectInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.connectInfo != nil && !minimock.Equal(*mm_want_ptrs.connectInfo, mm_got.connectInfo) {
				mmAddStreamByUserID.t.Errorf("StreamServiceMock.AddStreamByUserID got unexpected parameter connectInfo, want: %#v, got: %#v%s\n", *mm_want_ptrs.connectInfo, mm_got.connectInfo, minimock.Diff(*mm_want_ptrs.connectInfo, mm_got.connectInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddStreamByUserID.t.Errorf("StreamServiceMock.AddStreamByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddStreamByUserID.funcAddStreamByUserID != nil {
		mmAddStreamByUserID.funcAddStreamByUserID(connectInfo)
		return
	}
	mmAddStreamByUserID.t.Fatalf("Unexpected call to StreamServiceMock.AddStreamByUserID. %v", connectInfo)

}

// AddStreamByUserIDAfterCounter returns a count of finished StreamServiceMock.AddStreamByUserID invocations
func (mmAddStreamByUserID *StreamServiceMock) AddStreamByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStreamByUserID.afterAddStreamByUserIDCounter)
}

// AddStreamByUserIDBeforeCounter returns a count of StreamServiceMock.AddStreamByUserID invocations
func (mmAddStreamByUserID *StreamServiceMock) AddStreamByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStreamByUserID.beforeAddStreamByUserIDCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.AddStreamByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddStreamByUserID *mStreamServiceMockAddStreamByUserID) Calls() []*StreamServiceMockAddStreamByUserIDParams {
	mmAddStreamByUserID.mutex.RLock()

	argCopy := make([]*StreamServiceMockAddStreamByUserIDParams, len(mmAddStreamByUserID.callArgs))
	copy(argCopy, mmAddStreamByUserID.callArgs)

	mmAddStreamByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockAddStreamByUserIDDone returns true if the count of the AddStreamByUserID invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockAddStreamByUserIDDone() bool {
	if m.AddStreamByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddStreamByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddStreamByUserIDMock.invocationsDone()
}

// MinimockAddStreamByUserIDInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockAddStreamByUserIDInspect() {
	for _, e := range m.AddStreamByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.AddStreamByUserID with params: %#v", *e.params)
		}
	}

	afterAddStreamByUserIDCounter := mm_atomic.LoadUint64(&m.afterAddStreamByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddStreamByUserIDMock.defaultExpectation != nil && afterAddStreamByUserIDCounter < 1 {
		if m.AddStreamByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.AddStreamByUserID")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.AddStreamByUserID with params: %#v", *m.AddStreamByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStreamByUserID != nil && afterAddStreamByUserIDCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.AddStreamByUserID")
	}

	if !m.AddStreamByUserIDMock.invocationsDone() && afterAddStreamByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.AddStreamByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.AddStreamByUserIDMock.expectedInvocations), afterAddStreamByUserIDCounter)
	}
}

type mStreamServiceMockAddToChannel struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockAddToChannelExpectation
	expectations       []*StreamServiceMockAddToChannelExpectation

	callArgs []*StreamServiceMockAddToChannelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockAddToChannelExpectation specifies expectation struct of the StreamService.AddToChannel
type StreamServiceMockAddToChannelExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockAddToChannelParams
	paramPtrs *StreamServiceMockAddToChannelParamPtrs

	Counter uint64
}

// StreamServiceMockAddToChannelParams contains parameters of the StreamService.AddToChannel
type StreamServiceMockAddToChannelParams struct {
	ctx    context.Context
	chatID int64
}

// StreamServiceMockAddToChannelParamPtrs contains pointers to parameters of the StreamService.AddToChannel
type StreamServiceMockAddToChannelParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddToChannel *mStreamServiceMockAddToChannel) Optional() *mStreamServiceMockAddToChannel {
	mmAddToChannel.optional = true
	return mmAddToChannel
}

// Expect sets up expected params for StreamService.AddToChannel
func (mmAddToChannel *mStreamServiceMockAddToChannel) Expect(ctx context.Context, chatID int64) *mStreamServiceMockAddToChannel {
	if mmAddToChannel.mock.funcAddToChannel != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Set")
	}

	if mmAddToChannel.defaultExpectation == nil {
		mmAddToChannel.defaultExpectation = &StreamServiceMockAddToChannelExpectation{}
	}

	if mmAddToChannel.defaultExpectation.paramPtrs != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by ExpectParams functions")
	}

	mmAddToChannel.defaultExpectation.params = &StreamServiceMockAddToChannelParams{ctx, chatID}
	for _, e := range mmAddToChannel.expectations {
		if minimock.Equal(e.params, mmAddToChannel.defaultExpectation.params) {
			mmAddToChannel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToChannel.defaultExpectation.params)
		}
	}

	return mmAddToChannel
}

// ExpectCtxParam1 sets up expected param ctx for StreamService.AddToChannel
func (mmAddToChannel *mStreamServiceMockAddToChannel) ExpectCtxParam1(ctx context.Context) *mStreamServiceMockAddToChannel {
	if mmAddToChannel.mock.funcAddToChannel != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Set")
	}

	if mmAddToChannel.defaultExpectation == nil {
		mmAddToChannel.defaultExpectation = &StreamServiceMockAddToChannelExpectation{}
	}

	if mmAddToChannel.defaultExpectation.params != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Expect")
	}

	if mmAddToChannel.defaultExpectation.paramPtrs == nil {
		mmAddToChannel.defaultExpectation.paramPtrs = &StreamServiceMockAddToChannelParamPtrs{}
	}
	mmAddToChannel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddToChannel
}

// ExpectChatIDParam2 sets up expected param chatID for StreamService.AddToChannel
func (mmAddToChannel *mStreamServiceMockAddToChannel) ExpectChatIDParam2(chatID int64) *mStreamServiceMockAddToChannel {
	if mmAddToChannel.mock.funcAddToChannel != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Set")
	}

	if mmAddToChannel.defaultExpectation == nil {
		mmAddToChannel.defaultExpectation = &StreamServiceMockAddToChannelExpectation{}
	}

	if mmAddToChannel.defaultExpectation.params != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Expect")
	}

	if mmAddToChannel.defaultExpectation.paramPtrs == nil {
		mmAddToChannel.defaultExpectation.paramPtrs = &StreamServiceMockAddToChannelParamPtrs{}
	}
	mmAddToChannel.defaultExpectation.paramPtrs.chatID = &chatID

	return mmAddToChannel
}

// Inspect accepts an inspector function that has same arguments as the StreamService.AddToChannel
func (mmAddToChannel *mStreamServiceMockAddToChannel) Inspect(f func(ctx context.Context, chatID int64)) *mStreamServiceMockAddToChannel {
	if mmAddToChannel.mock.inspectFuncAddToChannel != nil {
		mmAddToChannel.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.AddToChannel")
	}

	mmAddToChannel.mock.inspectFuncAddToChannel = f

	return mmAddToChannel
}

// Return sets up results that will be returned by StreamService.AddToChannel
func (mmAddToChannel *mStreamServiceMockAddToChannel) Return() *StreamServiceMock {
	if mmAddToChannel.mock.funcAddToChannel != nil {
		mmAddToChannel.mock.t.Fatalf("StreamServiceMock.AddToChannel mock is already set by Set")
	}

	if mmAddToChannel.defaultExpectation == nil {
		mmAddToChannel.defaultExpectation = &StreamServiceMockAddToChannelExpectation{mock: mmAddToChannel.mock}
	}

	return mmAddToChannel.mock
}

// Set uses given function f to mock the StreamService.AddToChannel method
func (mmAddToChannel *mStreamServiceMockAddToChannel) Set(f func(ctx context.Context, chatID int64)) *StreamServiceMock {
	if mmAddToChannel.defaultExpectation != nil {
		mmAddToChannel.mock.t.Fatalf("Default expectation is already set for the StreamService.AddToChannel method")
	}

	if len(mmAddToChannel.expectations) > 0 {
		mmAddToChannel.mock.t.Fatalf("Some expectations are already set for the StreamService.AddToChannel method")
	}

	mmAddToChannel.mock.funcAddToChannel = f
	return mmAddToChannel.mock
}

// Times sets number of times StreamService.AddToChannel should be invoked
func (mmAddToChannel *mStreamServiceMockAddToChannel) Times(n uint64) *mStreamServiceMockAddToChannel {
	if n == 0 {
		mmAddToChannel.mock.t.Fatalf("Times of StreamServiceMock.AddToChannel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddToChannel.expectedInvocations, n)
	return mmAddToChannel
}

func (mmAddToChannel *mStreamServiceMockAddToChannel) invocationsDone() bool {
	if len(mmAddToChannel.expectations) == 0 && mmAddToChannel.defaultExpectation == nil && mmAddToChannel.mock.funcAddToChannel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddToChannel.mock.afterAddToChannelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddToChannel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddToChannel implements StreamService
func (mmAddToChannel *StreamServiceMock) AddToChannel(ctx context.Context, chatID int64) {
	mm_atomic.AddUint64(&mmAddToChannel.beforeAddToChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToChannel.afterAddToChannelCounter, 1)

	if mmAddToChannel.inspectFuncAddToChannel != nil {
		mmAddToChannel.inspectFuncAddToChannel(ctx, chatID)
	}

	mm_params := StreamServiceMockAddToChannelParams{ctx, chatID}

	// Record call args
	mmAddToChannel.AddToChannelMock.mutex.Lock()
	mmAddToChannel.AddToChannelMock.callArgs = append(mmAddToChannel.AddToChannelMock.callArgs, &mm_params)
	mmAddToChannel.AddToChannelMock.mutex.Unlock()

	for _, e := range mmAddToChannel.AddToChannelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddToChannel.AddToChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToChannel.AddToChannelMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToChannel.AddToChannelMock.defaultExpectation.params
		mm_want_ptrs := mmAddToChannel.AddToChannelMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockAddToChannelParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddToChannel.t.Errorf("StreamServiceMock.AddToChannel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmAddToChannel.t.Errorf("StreamServiceMock.AddToChannel got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToChannel.t.Errorf("StreamServiceMock.AddToChannel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddToChannel.funcAddToChannel != nil {
		mmAddToChannel.funcAddToChannel(ctx, chatID)
		return
	}
	mmAddToChannel.t.Fatalf("Unexpected call to StreamServiceMock.AddToChannel. %v %v", ctx, chatID)

}

// AddToChannelAfterCounter returns a count of finished StreamServiceMock.AddToChannel invocations
func (mmAddToChannel *StreamServiceMock) AddToChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToChannel.afterAddToChannelCounter)
}

// AddToChannelBeforeCounter returns a count of StreamServiceMock.AddToChannel invocations
func (mmAddToChannel *StreamServiceMock) AddToChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToChannel.beforeAddToChannelCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.AddToChannel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToChannel *mStreamServiceMockAddToChannel) Calls() []*StreamServiceMockAddToChannelParams {
	mmAddToChannel.mutex.RLock()

	argCopy := make([]*StreamServiceMockAddToChannelParams, len(mmAddToChannel.callArgs))
	copy(argCopy, mmAddToChannel.callArgs)

	mmAddToChannel.mutex.RUnlock()

	return argCopy
}

// MinimockAddToChannelDone returns true if the count of the AddToChannel invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockAddToChannelDone() bool {
	if m.AddToChannelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddToChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddToChannelMock.invocationsDone()
}

// MinimockAddToChannelInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockAddToChannelInspect() {
	for _, e := range m.AddToChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.AddToChannel with params: %#v", *e.params)
		}
	}

	afterAddToChannelCounter := mm_atomic.LoadUint64(&m.afterAddToChannelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddToChannelMock.defaultExpectation != nil && afterAddToChannelCounter < 1 {
		if m.AddToChannelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.AddToChannel")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.AddToChannel with params: %#v", *m.AddToChannelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToChannel != nil && afterAddToChannelCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.AddToChannel")
	}

	if !m.AddToChannelMock.invocationsDone() && afterAddToChannelCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.AddToChannel but found %d calls",
			mm_atomic.LoadUint64(&m.AddToChannelMock.expectedInvocations), afterAddToChannelCounter)
	}
}

type mStreamServiceMockDeleteStreamByUserID struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockDeleteStreamByUserIDExpectation
	expectations       []*StreamServiceMockDeleteStreamByUserIDExpectation

	callArgs []*StreamServiceMockDeleteStreamByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockDeleteStreamByUserIDExpectation specifies expectation struct of the StreamService.DeleteStreamByUserID
type StreamServiceMockDeleteStreamByUserIDExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockDeleteStreamByUserIDParams
	paramPtrs *StreamServiceMockDeleteStreamByUserIDParamPtrs

	Counter uint64
}

// StreamServiceMockDeleteStreamByUserIDParams contains parameters of the StreamService.DeleteStreamByUserID
type StreamServiceMockDeleteStreamByUserIDParams struct {
	chatID string
	userID string
}

// StreamServiceMockDeleteStreamByUserIDParamPtrs contains pointers to parameters of the StreamService.DeleteStreamByUserID
type StreamServiceMockDeleteStreamByUserIDParamPtrs struct {
	chatID *string
	userID *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Optional() *mStreamServiceMockDeleteStreamByUserID {
	mmDeleteStreamByUserID.optional = true
	return mmDeleteStreamByUserID
}

// Expect sets up expected params for StreamService.DeleteStreamByUserID
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Expect(chatID string, userID string) *mStreamServiceMockDeleteStreamByUserID {
	if mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Set")
	}

	if mmDeleteStreamByUserID.defaultExpectation == nil {
		mmDeleteStreamByUserID.defaultExpectation = &StreamServiceMockDeleteStreamByUserIDExpectation{}
	}

	if mmDeleteStreamByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteStreamByUserID.defaultExpectation.params = &StreamServiceMockDeleteStreamByUserIDParams{chatID, userID}
	for _, e := range mmDeleteStreamByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteStreamByUserID.defaultExpectation.params) {
			mmDeleteStreamByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStreamByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteStreamByUserID
}

// ExpectChatIDParam1 sets up expected param chatID for StreamService.DeleteStreamByUserID
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) ExpectChatIDParam1(chatID string) *mStreamServiceMockDeleteStreamByUserID {
	if mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Set")
	}

	if mmDeleteStreamByUserID.defaultExpectation == nil {
		mmDeleteStreamByUserID.defaultExpectation = &StreamServiceMockDeleteStreamByUserIDExpectation{}
	}

	if mmDeleteStreamByUserID.defaultExpectation.params != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Expect")
	}

	if mmDeleteStreamByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteStreamByUserID.defaultExpectation.paramPtrs = &StreamServiceMockDeleteStreamByUserIDParamPtrs{}
	}
	mmDeleteStreamByUserID.defaultExpectation.paramPtrs.chatID = &chatID

	return mmDeleteStreamByUserID
}

// ExpectUserIDParam2 sets up expected param userID for StreamService.DeleteStreamByUserID
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) ExpectUserIDParam2(userID string) *mStreamServiceMockDeleteStreamByUserID {
	if mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Set")
	}

	if mmDeleteStreamByUserID.defaultExpectation == nil {
		mmDeleteStreamByUserID.defaultExpectation = &StreamServiceMockDeleteStreamByUserIDExpectation{}
	}

	if mmDeleteStreamByUserID.defaultExpectation.params != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Expect")
	}

	if mmDeleteStreamByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteStreamByUserID.defaultExpectation.paramPtrs = &StreamServiceMockDeleteStreamByUserIDParamPtrs{}
	}
	mmDeleteStreamByUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteStreamByUserID
}

// Inspect accepts an inspector function that has same arguments as the StreamService.DeleteStreamByUserID
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Inspect(f func(chatID string, userID string)) *mStreamServiceMockDeleteStreamByUserID {
	if mmDeleteStreamByUserID.mock.inspectFuncDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.DeleteStreamByUserID")
	}

	mmDeleteStreamByUserID.mock.inspectFuncDeleteStreamByUserID = f

	return mmDeleteStreamByUserID
}

// Return sets up results that will be returned by StreamService.DeleteStreamByUserID
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Return() *StreamServiceMock {
	if mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("StreamServiceMock.DeleteStreamByUserID mock is already set by Set")
	}

	if mmDeleteStreamByUserID.defaultExpectation == nil {
		mmDeleteStreamByUserID.defaultExpectation = &StreamServiceMockDeleteStreamByUserIDExpectation{mock: mmDeleteStreamByUserID.mock}
	}

	return mmDeleteStreamByUserID.mock
}

// Set uses given function f to mock the StreamService.DeleteStreamByUserID method
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Set(f func(chatID string, userID string)) *StreamServiceMock {
	if mmDeleteStreamByUserID.defaultExpectation != nil {
		mmDeleteStreamByUserID.mock.t.Fatalf("Default expectation is already set for the StreamService.DeleteStreamByUserID method")
	}

	if len(mmDeleteStreamByUserID.expectations) > 0 {
		mmDeleteStreamByUserID.mock.t.Fatalf("Some expectations are already set for the StreamService.DeleteStreamByUserID method")
	}

	mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID = f
	return mmDeleteStreamByUserID.mock
}

// Times sets number of times StreamService.DeleteStreamByUserID should be invoked
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Times(n uint64) *mStreamServiceMockDeleteStreamByUserID {
	if n == 0 {
		mmDeleteStreamByUserID.mock.t.Fatalf("Times of StreamServiceMock.DeleteStreamByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteStreamByUserID.expectedInvocations, n)
	return mmDeleteStreamByUserID
}

func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) invocationsDone() bool {
	if len(mmDeleteStreamByUserID.expectations) == 0 && mmDeleteStreamByUserID.defaultExpectation == nil && mmDeleteStreamByUserID.mock.funcDeleteStreamByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteStreamByUserID.mock.afterDeleteStreamByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteStreamByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteStreamByUserID implements StreamService
func (mmDeleteStreamByUserID *StreamServiceMock) DeleteStreamByUserID(chatID string, userID string) {
	mm_atomic.AddUint64(&mmDeleteStreamByUserID.beforeDeleteStreamByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStreamByUserID.afterDeleteStreamByUserIDCounter, 1)

	if mmDeleteStreamByUserID.inspectFuncDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.inspectFuncDeleteStreamByUserID(chatID, userID)
	}

	mm_params := StreamServiceMockDeleteStreamByUserIDParams{chatID, userID}

	// Record call args
	mmDeleteStreamByUserID.DeleteStreamByUserIDMock.mutex.Lock()
	mmDeleteStreamByUserID.DeleteStreamByUserIDMock.callArgs = append(mmDeleteStreamByUserID.DeleteStreamByUserIDMock.callArgs, &mm_params)
	mmDeleteStreamByUserID.DeleteStreamByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteStreamByUserID.DeleteStreamByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteStreamByUserID.DeleteStreamByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStreamByUserID.DeleteStreamByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStreamByUserID.DeleteStreamByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteStreamByUserID.DeleteStreamByUserIDMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockDeleteStreamByUserIDParams{chatID, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteStreamByUserID.t.Errorf("StreamServiceMock.DeleteStreamByUserID got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteStreamByUserID.t.Errorf("StreamServiceMock.DeleteStreamByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStreamByUserID.t.Errorf("StreamServiceMock.DeleteStreamByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteStreamByUserID.funcDeleteStreamByUserID != nil {
		mmDeleteStreamByUserID.funcDeleteStreamByUserID(chatID, userID)
		return
	}
	mmDeleteStreamByUserID.t.Fatalf("Unexpected call to StreamServiceMock.DeleteStreamByUserID. %v %v", chatID, userID)

}

// DeleteStreamByUserIDAfterCounter returns a count of finished StreamServiceMock.DeleteStreamByUserID invocations
func (mmDeleteStreamByUserID *StreamServiceMock) DeleteStreamByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStreamByUserID.afterDeleteStreamByUserIDCounter)
}

// DeleteStreamByUserIDBeforeCounter returns a count of StreamServiceMock.DeleteStreamByUserID invocations
func (mmDeleteStreamByUserID *StreamServiceMock) DeleteStreamByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStreamByUserID.beforeDeleteStreamByUserIDCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.DeleteStreamByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStreamByUserID *mStreamServiceMockDeleteStreamByUserID) Calls() []*StreamServiceMockDeleteStreamByUserIDParams {
	mmDeleteStreamByUserID.mutex.RLock()

	argCopy := make([]*StreamServiceMockDeleteStreamByUserIDParams, len(mmDeleteStreamByUserID.callArgs))
	copy(argCopy, mmDeleteStreamByUserID.callArgs)

	mmDeleteStreamByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStreamByUserIDDone returns true if the count of the DeleteStreamByUserID invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockDeleteStreamByUserIDDone() bool {
	if m.DeleteStreamByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteStreamByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteStreamByUserIDMock.invocationsDone()
}

// MinimockDeleteStreamByUserIDInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockDeleteStreamByUserIDInspect() {
	for _, e := range m.DeleteStreamByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.DeleteStreamByUserID with params: %#v", *e.params)
		}
	}

	afterDeleteStreamByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteStreamByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStreamByUserIDMock.defaultExpectation != nil && afterDeleteStreamByUserIDCounter < 1 {
		if m.DeleteStreamByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.DeleteStreamByUserID")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.DeleteStreamByUserID with params: %#v", *m.DeleteStreamByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStreamByUserID != nil && afterDeleteStreamByUserIDCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.DeleteStreamByUserID")
	}

	if !m.DeleteStreamByUserIDMock.invocationsDone() && afterDeleteStreamByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.DeleteStreamByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteStreamByUserIDMock.expectedInvocations), afterDeleteStreamByUserIDCounter)
	}
}

type mStreamServiceMockGetChatChannel struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockGetChatChannelExpectation
	expectations       []*StreamServiceMockGetChatChannelExpectation

	callArgs []*StreamServiceMockGetChatChannelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockGetChatChannelExpectation specifies expectation struct of the StreamService.GetChatChannel
type StreamServiceMockGetChatChannelExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockGetChatChannelParams
	paramPtrs *StreamServiceMockGetChatChannelParamPtrs
	results   *StreamServiceMockGetChatChannelResults
	Counter   uint64
}

// StreamServiceMockGetChatChannelParams contains parameters of the StreamService.GetChatChannel
type StreamServiceMockGetChatChannelParams struct {
	ctx    context.Context
	chatID string
}

// StreamServiceMockGetChatChannelParamPtrs contains pointers to parameters of the StreamService.GetChatChannel
type StreamServiceMockGetChatChannelParamPtrs struct {
	ctx    *context.Context
	chatID *string
}

// StreamServiceMockGetChatChannelResults contains results of the StreamService.GetChatChannel
type StreamServiceMockGetChatChannelResults struct {
	ch1 chan *model.StreamMessage
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Optional() *mStreamServiceMockGetChatChannel {
	mmGetChatChannel.optional = true
	return mmGetChatChannel
}

// Expect sets up expected params for StreamService.GetChatChannel
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Expect(ctx context.Context, chatID string) *mStreamServiceMockGetChatChannel {
	if mmGetChatChannel.mock.funcGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Set")
	}

	if mmGetChatChannel.defaultExpectation == nil {
		mmGetChatChannel.defaultExpectation = &StreamServiceMockGetChatChannelExpectation{}
	}

	if mmGetChatChannel.defaultExpectation.paramPtrs != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by ExpectParams functions")
	}

	mmGetChatChannel.defaultExpectation.params = &StreamServiceMockGetChatChannelParams{ctx, chatID}
	for _, e := range mmGetChatChannel.expectations {
		if minimock.Equal(e.params, mmGetChatChannel.defaultExpectation.params) {
			mmGetChatChannel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatChannel.defaultExpectation.params)
		}
	}

	return mmGetChatChannel
}

// ExpectCtxParam1 sets up expected param ctx for StreamService.GetChatChannel
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) ExpectCtxParam1(ctx context.Context) *mStreamServiceMockGetChatChannel {
	if mmGetChatChannel.mock.funcGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Set")
	}

	if mmGetChatChannel.defaultExpectation == nil {
		mmGetChatChannel.defaultExpectation = &StreamServiceMockGetChatChannelExpectation{}
	}

	if mmGetChatChannel.defaultExpectation.params != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Expect")
	}

	if mmGetChatChannel.defaultExpectation.paramPtrs == nil {
		mmGetChatChannel.defaultExpectation.paramPtrs = &StreamServiceMockGetChatChannelParamPtrs{}
	}
	mmGetChatChannel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetChatChannel
}

// ExpectChatIDParam2 sets up expected param chatID for StreamService.GetChatChannel
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) ExpectChatIDParam2(chatID string) *mStreamServiceMockGetChatChannel {
	if mmGetChatChannel.mock.funcGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Set")
	}

	if mmGetChatChannel.defaultExpectation == nil {
		mmGetChatChannel.defaultExpectation = &StreamServiceMockGetChatChannelExpectation{}
	}

	if mmGetChatChannel.defaultExpectation.params != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Expect")
	}

	if mmGetChatChannel.defaultExpectation.paramPtrs == nil {
		mmGetChatChannel.defaultExpectation.paramPtrs = &StreamServiceMockGetChatChannelParamPtrs{}
	}
	mmGetChatChannel.defaultExpectation.paramPtrs.chatID = &chatID

	return mmGetChatChannel
}

// Inspect accepts an inspector function that has same arguments as the StreamService.GetChatChannel
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Inspect(f func(ctx context.Context, chatID string)) *mStreamServiceMockGetChatChannel {
	if mmGetChatChannel.mock.inspectFuncGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.GetChatChannel")
	}

	mmGetChatChannel.mock.inspectFuncGetChatChannel = f

	return mmGetChatChannel
}

// Return sets up results that will be returned by StreamService.GetChatChannel
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Return(ch1 chan *model.StreamMessage, err error) *StreamServiceMock {
	if mmGetChatChannel.mock.funcGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Set")
	}

	if mmGetChatChannel.defaultExpectation == nil {
		mmGetChatChannel.defaultExpectation = &StreamServiceMockGetChatChannelExpectation{mock: mmGetChatChannel.mock}
	}
	mmGetChatChannel.defaultExpectation.results = &StreamServiceMockGetChatChannelResults{ch1, err}
	return mmGetChatChannel.mock
}

// Set uses given function f to mock the StreamService.GetChatChannel method
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Set(f func(ctx context.Context, chatID string) (ch1 chan *model.StreamMessage, err error)) *StreamServiceMock {
	if mmGetChatChannel.defaultExpectation != nil {
		mmGetChatChannel.mock.t.Fatalf("Default expectation is already set for the StreamService.GetChatChannel method")
	}

	if len(mmGetChatChannel.expectations) > 0 {
		mmGetChatChannel.mock.t.Fatalf("Some expectations are already set for the StreamService.GetChatChannel method")
	}

	mmGetChatChannel.mock.funcGetChatChannel = f
	return mmGetChatChannel.mock
}

// When sets expectation for the StreamService.GetChatChannel which will trigger the result defined by the following
// Then helper
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) When(ctx context.Context, chatID string) *StreamServiceMockGetChatChannelExpectation {
	if mmGetChatChannel.mock.funcGetChatChannel != nil {
		mmGetChatChannel.mock.t.Fatalf("StreamServiceMock.GetChatChannel mock is already set by Set")
	}

	expectation := &StreamServiceMockGetChatChannelExpectation{
		mock:   mmGetChatChannel.mock,
		params: &StreamServiceMockGetChatChannelParams{ctx, chatID},
	}
	mmGetChatChannel.expectations = append(mmGetChatChannel.expectations, expectation)
	return expectation
}

// Then sets up StreamService.GetChatChannel return parameters for the expectation previously defined by the When method
func (e *StreamServiceMockGetChatChannelExpectation) Then(ch1 chan *model.StreamMessage, err error) *StreamServiceMock {
	e.results = &StreamServiceMockGetChatChannelResults{ch1, err}
	return e.mock
}

// Times sets number of times StreamService.GetChatChannel should be invoked
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Times(n uint64) *mStreamServiceMockGetChatChannel {
	if n == 0 {
		mmGetChatChannel.mock.t.Fatalf("Times of StreamServiceMock.GetChatChannel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatChannel.expectedInvocations, n)
	return mmGetChatChannel
}

func (mmGetChatChannel *mStreamServiceMockGetChatChannel) invocationsDone() bool {
	if len(mmGetChatChannel.expectations) == 0 && mmGetChatChannel.defaultExpectation == nil && mmGetChatChannel.mock.funcGetChatChannel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatChannel.mock.afterGetChatChannelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatChannel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatChannel implements StreamService
func (mmGetChatChannel *StreamServiceMock) GetChatChannel(ctx context.Context, chatID string) (ch1 chan *model.StreamMessage, err error) {
	mm_atomic.AddUint64(&mmGetChatChannel.beforeGetChatChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatChannel.afterGetChatChannelCounter, 1)

	if mmGetChatChannel.inspectFuncGetChatChannel != nil {
		mmGetChatChannel.inspectFuncGetChatChannel(ctx, chatID)
	}

	mm_params := StreamServiceMockGetChatChannelParams{ctx, chatID}

	// Record call args
	mmGetChatChannel.GetChatChannelMock.mutex.Lock()
	mmGetChatChannel.GetChatChannelMock.callArgs = append(mmGetChatChannel.GetChatChannelMock.callArgs, &mm_params)
	mmGetChatChannel.GetChatChannelMock.mutex.Unlock()

	for _, e := range mmGetChatChannel.GetChatChannelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1, e.results.err
		}
	}

	if mmGetChatChannel.GetChatChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatChannel.GetChatChannelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatChannel.GetChatChannelMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatChannel.GetChatChannelMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockGetChatChannelParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatChannel.t.Errorf("StreamServiceMock.GetChatChannel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetChatChannel.t.Errorf("StreamServiceMock.GetChatChannel got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatChannel.t.Errorf("StreamServiceMock.GetChatChannel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatChannel.GetChatChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatChannel.t.Fatal("No results are set for the StreamServiceMock.GetChatChannel")
		}
		return (*mm_results).ch1, (*mm_results).err
	}
	if mmGetChatChannel.funcGetChatChannel != nil {
		return mmGetChatChannel.funcGetChatChannel(ctx, chatID)
	}
	mmGetChatChannel.t.Fatalf("Unexpected call to StreamServiceMock.GetChatChannel. %v %v", ctx, chatID)
	return
}

// GetChatChannelAfterCounter returns a count of finished StreamServiceMock.GetChatChannel invocations
func (mmGetChatChannel *StreamServiceMock) GetChatChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatChannel.afterGetChatChannelCounter)
}

// GetChatChannelBeforeCounter returns a count of StreamServiceMock.GetChatChannel invocations
func (mmGetChatChannel *StreamServiceMock) GetChatChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatChannel.beforeGetChatChannelCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.GetChatChannel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatChannel *mStreamServiceMockGetChatChannel) Calls() []*StreamServiceMockGetChatChannelParams {
	mmGetChatChannel.mutex.RLock()

	argCopy := make([]*StreamServiceMockGetChatChannelParams, len(mmGetChatChannel.callArgs))
	copy(argCopy, mmGetChatChannel.callArgs)

	mmGetChatChannel.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatChannelDone returns true if the count of the GetChatChannel invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockGetChatChannelDone() bool {
	if m.GetChatChannelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatChannelMock.invocationsDone()
}

// MinimockGetChatChannelInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockGetChatChannelInspect() {
	for _, e := range m.GetChatChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.GetChatChannel with params: %#v", *e.params)
		}
	}

	afterGetChatChannelCounter := mm_atomic.LoadUint64(&m.afterGetChatChannelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatChannelMock.defaultExpectation != nil && afterGetChatChannelCounter < 1 {
		if m.GetChatChannelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.GetChatChannel")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.GetChatChannel with params: %#v", *m.GetChatChannelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatChannel != nil && afterGetChatChannelCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.GetChatChannel")
	}

	if !m.GetChatChannelMock.invocationsDone() && afterGetChatChannelCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.GetChatChannel but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatChannelMock.expectedInvocations), afterGetChatChannelCounter)
	}
}

type mStreamServiceMockSendMessageToStreams struct {
	optional           bool
	mock               *StreamServiceMock
	defaultExpectation *StreamServiceMockSendMessageToStreamsExpectation
	expectations       []*StreamServiceMockSendMessageToStreamsExpectation

	callArgs []*StreamServiceMockSendMessageToStreamsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StreamServiceMockSendMessageToStreamsExpectation specifies expectation struct of the StreamService.SendMessageToStreams
type StreamServiceMockSendMessageToStreamsExpectation struct {
	mock      *StreamServiceMock
	params    *StreamServiceMockSendMessageToStreamsParams
	paramPtrs *StreamServiceMockSendMessageToStreamsParamPtrs
	results   *StreamServiceMockSendMessageToStreamsResults
	Counter   uint64
}

// StreamServiceMockSendMessageToStreamsParams contains parameters of the StreamService.SendMessageToStreams
type StreamServiceMockSendMessageToStreamsParams struct {
	chatID string
	msg    *model.StreamMessage
}

// StreamServiceMockSendMessageToStreamsParamPtrs contains pointers to parameters of the StreamService.SendMessageToStreams
type StreamServiceMockSendMessageToStreamsParamPtrs struct {
	chatID *string
	msg    **model.StreamMessage
}

// StreamServiceMockSendMessageToStreamsResults contains results of the StreamService.SendMessageToStreams
type StreamServiceMockSendMessageToStreamsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Optional() *mStreamServiceMockSendMessageToStreams {
	mmSendMessageToStreams.optional = true
	return mmSendMessageToStreams
}

// Expect sets up expected params for StreamService.SendMessageToStreams
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Expect(chatID string, msg *model.StreamMessage) *mStreamServiceMockSendMessageToStreams {
	if mmSendMessageToStreams.mock.funcSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Set")
	}

	if mmSendMessageToStreams.defaultExpectation == nil {
		mmSendMessageToStreams.defaultExpectation = &StreamServiceMockSendMessageToStreamsExpectation{}
	}

	if mmSendMessageToStreams.defaultExpectation.paramPtrs != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by ExpectParams functions")
	}

	mmSendMessageToStreams.defaultExpectation.params = &StreamServiceMockSendMessageToStreamsParams{chatID, msg}
	for _, e := range mmSendMessageToStreams.expectations {
		if minimock.Equal(e.params, mmSendMessageToStreams.defaultExpectation.params) {
			mmSendMessageToStreams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessageToStreams.defaultExpectation.params)
		}
	}

	return mmSendMessageToStreams
}

// ExpectChatIDParam1 sets up expected param chatID for StreamService.SendMessageToStreams
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) ExpectChatIDParam1(chatID string) *mStreamServiceMockSendMessageToStreams {
	if mmSendMessageToStreams.mock.funcSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Set")
	}

	if mmSendMessageToStreams.defaultExpectation == nil {
		mmSendMessageToStreams.defaultExpectation = &StreamServiceMockSendMessageToStreamsExpectation{}
	}

	if mmSendMessageToStreams.defaultExpectation.params != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Expect")
	}

	if mmSendMessageToStreams.defaultExpectation.paramPtrs == nil {
		mmSendMessageToStreams.defaultExpectation.paramPtrs = &StreamServiceMockSendMessageToStreamsParamPtrs{}
	}
	mmSendMessageToStreams.defaultExpectation.paramPtrs.chatID = &chatID

	return mmSendMessageToStreams
}

// ExpectMsgParam2 sets up expected param msg for StreamService.SendMessageToStreams
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) ExpectMsgParam2(msg *model.StreamMessage) *mStreamServiceMockSendMessageToStreams {
	if mmSendMessageToStreams.mock.funcSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Set")
	}

	if mmSendMessageToStreams.defaultExpectation == nil {
		mmSendMessageToStreams.defaultExpectation = &StreamServiceMockSendMessageToStreamsExpectation{}
	}

	if mmSendMessageToStreams.defaultExpectation.params != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Expect")
	}

	if mmSendMessageToStreams.defaultExpectation.paramPtrs == nil {
		mmSendMessageToStreams.defaultExpectation.paramPtrs = &StreamServiceMockSendMessageToStreamsParamPtrs{}
	}
	mmSendMessageToStreams.defaultExpectation.paramPtrs.msg = &msg

	return mmSendMessageToStreams
}

// Inspect accepts an inspector function that has same arguments as the StreamService.SendMessageToStreams
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Inspect(f func(chatID string, msg *model.StreamMessage)) *mStreamServiceMockSendMessageToStreams {
	if mmSendMessageToStreams.mock.inspectFuncSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("Inspect function is already set for StreamServiceMock.SendMessageToStreams")
	}

	mmSendMessageToStreams.mock.inspectFuncSendMessageToStreams = f

	return mmSendMessageToStreams
}

// Return sets up results that will be returned by StreamService.SendMessageToStreams
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Return(err error) *StreamServiceMock {
	if mmSendMessageToStreams.mock.funcSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Set")
	}

	if mmSendMessageToStreams.defaultExpectation == nil {
		mmSendMessageToStreams.defaultExpectation = &StreamServiceMockSendMessageToStreamsExpectation{mock: mmSendMessageToStreams.mock}
	}
	mmSendMessageToStreams.defaultExpectation.results = &StreamServiceMockSendMessageToStreamsResults{err}
	return mmSendMessageToStreams.mock
}

// Set uses given function f to mock the StreamService.SendMessageToStreams method
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Set(f func(chatID string, msg *model.StreamMessage) (err error)) *StreamServiceMock {
	if mmSendMessageToStreams.defaultExpectation != nil {
		mmSendMessageToStreams.mock.t.Fatalf("Default expectation is already set for the StreamService.SendMessageToStreams method")
	}

	if len(mmSendMessageToStreams.expectations) > 0 {
		mmSendMessageToStreams.mock.t.Fatalf("Some expectations are already set for the StreamService.SendMessageToStreams method")
	}

	mmSendMessageToStreams.mock.funcSendMessageToStreams = f
	return mmSendMessageToStreams.mock
}

// When sets expectation for the StreamService.SendMessageToStreams which will trigger the result defined by the following
// Then helper
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) When(chatID string, msg *model.StreamMessage) *StreamServiceMockSendMessageToStreamsExpectation {
	if mmSendMessageToStreams.mock.funcSendMessageToStreams != nil {
		mmSendMessageToStreams.mock.t.Fatalf("StreamServiceMock.SendMessageToStreams mock is already set by Set")
	}

	expectation := &StreamServiceMockSendMessageToStreamsExpectation{
		mock:   mmSendMessageToStreams.mock,
		params: &StreamServiceMockSendMessageToStreamsParams{chatID, msg},
	}
	mmSendMessageToStreams.expectations = append(mmSendMessageToStreams.expectations, expectation)
	return expectation
}

// Then sets up StreamService.SendMessageToStreams return parameters for the expectation previously defined by the When method
func (e *StreamServiceMockSendMessageToStreamsExpectation) Then(err error) *StreamServiceMock {
	e.results = &StreamServiceMockSendMessageToStreamsResults{err}
	return e.mock
}

// Times sets number of times StreamService.SendMessageToStreams should be invoked
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Times(n uint64) *mStreamServiceMockSendMessageToStreams {
	if n == 0 {
		mmSendMessageToStreams.mock.t.Fatalf("Times of StreamServiceMock.SendMessageToStreams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessageToStreams.expectedInvocations, n)
	return mmSendMessageToStreams
}

func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) invocationsDone() bool {
	if len(mmSendMessageToStreams.expectations) == 0 && mmSendMessageToStreams.defaultExpectation == nil && mmSendMessageToStreams.mock.funcSendMessageToStreams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessageToStreams.mock.afterSendMessageToStreamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessageToStreams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessageToStreams implements StreamService
func (mmSendMessageToStreams *StreamServiceMock) SendMessageToStreams(chatID string, msg *model.StreamMessage) (err error) {
	mm_atomic.AddUint64(&mmSendMessageToStreams.beforeSendMessageToStreamsCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessageToStreams.afterSendMessageToStreamsCounter, 1)

	if mmSendMessageToStreams.inspectFuncSendMessageToStreams != nil {
		mmSendMessageToStreams.inspectFuncSendMessageToStreams(chatID, msg)
	}

	mm_params := StreamServiceMockSendMessageToStreamsParams{chatID, msg}

	// Record call args
	mmSendMessageToStreams.SendMessageToStreamsMock.mutex.Lock()
	mmSendMessageToStreams.SendMessageToStreamsMock.callArgs = append(mmSendMessageToStreams.SendMessageToStreamsMock.callArgs, &mm_params)
	mmSendMessageToStreams.SendMessageToStreamsMock.mutex.Unlock()

	for _, e := range mmSendMessageToStreams.SendMessageToStreamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessageToStreams.SendMessageToStreamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessageToStreams.SendMessageToStreamsMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessageToStreams.SendMessageToStreamsMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessageToStreams.SendMessageToStreamsMock.defaultExpectation.paramPtrs

		mm_got := StreamServiceMockSendMessageToStreamsParams{chatID, msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmSendMessageToStreams.t.Errorf("StreamServiceMock.SendMessageToStreams got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmSendMessageToStreams.t.Errorf("StreamServiceMock.SendMessageToStreams got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessageToStreams.t.Errorf("StreamServiceMock.SendMessageToStreams got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessageToStreams.SendMessageToStreamsMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessageToStreams.t.Fatal("No results are set for the StreamServiceMock.SendMessageToStreams")
		}
		return (*mm_results).err
	}
	if mmSendMessageToStreams.funcSendMessageToStreams != nil {
		return mmSendMessageToStreams.funcSendMessageToStreams(chatID, msg)
	}
	mmSendMessageToStreams.t.Fatalf("Unexpected call to StreamServiceMock.SendMessageToStreams. %v %v", chatID, msg)
	return
}

// SendMessageToStreamsAfterCounter returns a count of finished StreamServiceMock.SendMessageToStreams invocations
func (mmSendMessageToStreams *StreamServiceMock) SendMessageToStreamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessageToStreams.afterSendMessageToStreamsCounter)
}

// SendMessageToStreamsBeforeCounter returns a count of StreamServiceMock.SendMessageToStreams invocations
func (mmSendMessageToStreams *StreamServiceMock) SendMessageToStreamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessageToStreams.beforeSendMessageToStreamsCounter)
}

// Calls returns a list of arguments used in each call to StreamServiceMock.SendMessageToStreams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessageToStreams *mStreamServiceMockSendMessageToStreams) Calls() []*StreamServiceMockSendMessageToStreamsParams {
	mmSendMessageToStreams.mutex.RLock()

	argCopy := make([]*StreamServiceMockSendMessageToStreamsParams, len(mmSendMessageToStreams.callArgs))
	copy(argCopy, mmSendMessageToStreams.callArgs)

	mmSendMessageToStreams.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageToStreamsDone returns true if the count of the SendMessageToStreams invocations corresponds
// the number of defined expectations
func (m *StreamServiceMock) MinimockSendMessageToStreamsDone() bool {
	if m.SendMessageToStreamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageToStreamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageToStreamsMock.invocationsDone()
}

// MinimockSendMessageToStreamsInspect logs each unmet expectation
func (m *StreamServiceMock) MinimockSendMessageToStreamsInspect() {
	for _, e := range m.SendMessageToStreamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamServiceMock.SendMessageToStreams with params: %#v", *e.params)
		}
	}

	afterSendMessageToStreamsCounter := mm_atomic.LoadUint64(&m.afterSendMessageToStreamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageToStreamsMock.defaultExpectation != nil && afterSendMessageToStreamsCounter < 1 {
		if m.SendMessageToStreamsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamServiceMock.SendMessageToStreams")
		} else {
			m.t.Errorf("Expected call to StreamServiceMock.SendMessageToStreams with params: %#v", *m.SendMessageToStreamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessageToStreams != nil && afterSendMessageToStreamsCounter < 1 {
		m.t.Error("Expected call to StreamServiceMock.SendMessageToStreams")
	}

	if !m.SendMessageToStreamsMock.invocationsDone() && afterSendMessageToStreamsCounter > 0 {
		m.t.Errorf("Expected %d calls to StreamServiceMock.SendMessageToStreams but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageToStreamsMock.expectedInvocations), afterSendMessageToStreamsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StreamServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddMessageToChatInspect()

			m.MinimockAddStreamByUserIDInspect()

			m.MinimockAddToChannelInspect()

			m.MinimockDeleteStreamByUserIDInspect()

			m.MinimockGetChatChannelInspect()

			m.MinimockSendMessageToStreamsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StreamServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StreamServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddMessageToChatDone() &&
		m.MinimockAddStreamByUserIDDone() &&
		m.MinimockAddToChannelDone() &&
		m.MinimockDeleteStreamByUserIDDone() &&
		m.MinimockGetChatChannelDone() &&
		m.MinimockSendMessageToStreamsDone()
}
